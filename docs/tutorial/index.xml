<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tutorial part 1 :: Web Apps in Lisp: Know-how</title><link>http://example.org/tutorial/index.html</link><description>Are you ready to build a web app in Common Lisp?
In this first tutorial we will build a simple app that shows a web form that will search and display a list of products.
In doing so, we will see many necessary building blocks to write web apps in Lisp:
how to start a server how to create routes how to define and use path and URL parameters how to define HTML templates how to run and build the app, from our editor and from the terminal. In doing so, we’ll experience the interactive nature of Common Lisp and we’ll learn important commands: running sbcl from the command line with a couple options, what is load, how to interactively compile our app with a keyboard shortcut, how to structure a project with an .asd definition and a package, etc.</description><generator>Hugo</generator><language>en-us</language><atom:link href="http://example.org/tutorial/index.xml" rel="self" type="application/rss+xml"/><item><title>Getting Started</title><link>http://example.org/tutorial/getting-started/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/tutorial/getting-started/index.html</guid><description>In this application we will:
define a list of products, stored in a dummy database, we’ll have an index page with a search form, we’ll display search results, and have one page per product to see it in details. But everything starts with a project (a system in Lisp parlance) definition.
Setting up the project Let’s create a regular Common Lisp project.
We could start straihgt from the REPL, but we’ll need a project definition to save our project dependencies, and other metadata. Such a project is an ASDF file.</description></item><item><title>the first route</title><link>http://example.org/tutorial/first-route/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/tutorial/first-route/index.html</guid><description>It’s time we create a web app!
Our first route Our very first route will only respond with a “hello world”.
Let’s start with a couple variables.
;; still in src/myproject.lisp (defvar *server* nil "Server instance (Hunchentoot acceptor).") (defparameter *port* 8899 "The application port.") Now hold yourself and let’s write our first route:
(easy-routes:defroute root ("/") () "hello app") It only returns a string. We’ll use HTML templates in a second.</description></item><item><title>the first template</title><link>http://example.org/tutorial/first-template/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/tutorial/first-template/index.html</guid><description>Our route only returns a string:
(easy-routes:defroute root ("/") () "hello app") Can we have it return a template?
We’ll use Djula HTML templates.
Usually, templates go into their templates/ directory. But, we will start out by defining our first template inside our .lisp file:
;; scr/myproject.lisp (defparameter *template-root* " &lt;title> Lisp web app &lt;/title> &lt;body> hello app &lt;/body> ") Compile this variable as you go, with C-c C-c (or call again load from any REPL).</description></item><item><title>the first path parameter</title><link>http://example.org/tutorial/first-path-parameter/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/tutorial/first-path-parameter/index.html</guid><description>So far we have 1 route that displays all our products.
We will make each product line clickable, to open a new page, that will show more details.
Each product detail will be available on the URL /product/n where n is the product ID.
Add links To begin with, let’s add links to the list of products:
(defparameter *template-root* " &lt;title> Lisp web app &lt;/title> &lt;body> &lt;ul> {% for product in products %} &lt;li> &lt;a href=\"/product/{{ product.0 }}\">{{ product.1 }} - {{ product.2 }}&lt;/a> &lt;/li> {% endfor %} &lt;/ul> &lt;/body> ") Carefully observe that, in the href, we had to escape the quotes :/ This is the shortcoming of defining Djula templates as strings in .lisp files. It’s best to move them to their own directory and own files.</description></item><item><title>the first URL parameter</title><link>http://example.org/tutorial/first-url-parameters/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/tutorial/first-url-parameters/index.html</guid><description>As of now we can access URLs like these: http://localhost:8899/product/0 where 0 is a path parameter.
We will soon need URL parameters so let’s add one to our routes.
We want a debug URL parameter that will show us more data. The URL will accept a ?debug=t part.
We have this product route:
(easy-routes:defroute product-route ("/product/:n") (&amp;path (n 'integer)) (render *template-product* :product (get-product n))) With or without the &amp;path part, either is good for now, so let’s remove it for clarity:</description></item><item><title>the first form</title><link>http://example.org/tutorial/first-form/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/tutorial/first-form/index.html</guid><description>Our root page shows a list of products. We want to do better: provide a search form.
Do you find HTML forms boring, very boring tech? There is no escaping though, you must know the basics. Go read MDN. It’s only later that you’ll have the right to find and use libraries to do them for you.
A search form Here’s a search form:
(defparameter *template-root* " &lt;form action=\"/\" method=\"GET\"> &lt;div> &lt;label for=\"query\">What do you search for?&lt;/label> &lt;input name=\"query\" id=\"query\" placeholder=\"Search…\" /> &lt;/div> &lt;div> &lt;button>Search&lt;/button> &lt;/div> &lt;/form> ") The important elements are the following:</description></item><item><title>Bonus: pimp your CSS</title><link>http://example.org/tutorial/first-bonus-css/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/tutorial/first-bonus-css/index.html</guid><description>Bonus: pimp your CSS Don’t ask a web developer to help you with the look and feel of the app, they will bring in hundreds of megabytes of Nodejs dependencies :S We suggest a (nearly) one-liner to get a decent CSS with no efforts: by using a class-less CSS, such as Pico.
We only need to load it in a &lt;head> tag of our app.
Optionally, we may write one &lt;div> with a class="container" attribute, to have better margins.</description></item><item><title>the first build</title><link>http://example.org/tutorial/first-build/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/tutorial/first-build/index.html</guid><description>We have developped a web app in Common Lisp.
At the first step, we opened a REPL and since then, without noticing, we have compiled variables and function definitions pieces by pieces, step by step, with keyboard shortcuts giving immediate feedback, testing our progress on the go, running a function in the REPL or refreshing the browser window.
Info We didn’t have to restart any Lisp process, nor any web server.</description></item></channel></rss>