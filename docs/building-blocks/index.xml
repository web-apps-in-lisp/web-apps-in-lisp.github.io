<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Building blocks :: Web Apps in Lisp: Know-how</title><link>http://example.org/building-blocks/index.html</link><description>In this chapter we’ll create routes, we’ll serve local files and we’ll run more than one web app in the same running image.
We’ll use those libraries:
(ql:quickload '("hunchentoot" "easy-routes" "djula" "spinneret")) Info You can create a web project with our project generator: cl-cookieweb.
We will use the Hunchentoot web server, but we should say a few words about Clack too.
Hunchentoot is
a web server and at the same time a toolkit for building dynamic websites. As a stand-alone web server, Hunchentoot is capable of HTTP/1.1 chunking (both directions), persistent connections (keep-alive), and SSL. It provides facilities like automatic session handling (with and without cookies), logging, customizable error handling, and easy access to GET and POST parameters sent by the client.</description><generator>Hugo</generator><language>en-us</language><atom:link href="http://example.org/building-blocks/index.xml" rel="self" type="application/rss+xml"/><item><title>Simple web server</title><link>http://example.org/building-blocks/simple-web-server/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/building-blocks/simple-web-server/index.html</guid><description>Before dwelving into web development, we might want to do something simple: serve some files we have on disk.
Serve local files If you followed the tutorial you know that we can create and start a webserver like this:
(defvar *acceptor* (make-instance 'hunchentoot:easy-acceptor :port 4242)) (hunchentoot:start *acceptor*) We create an instance of easy-acceptor on port 4242 and we start it. We can now access http://127.0.0.1:4242/. You should get a welcome screen with a link to the documentation and logs to the console.</description></item><item><title>Static assets</title><link>http://example.org/building-blocks/static/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/building-blocks/static/index.html</guid><description>How can we serve static assets?
Remember from simple web server how Hunchentoot serves files from a www/ directory by default. We can change that.
Hunchentoot Use the create-folder-dispatcher-and-handler prefix directory function.
For example:
(defun serve-static-assets () "Let Hunchentoot serve static assets under the /src/static/ directory of your :myproject system. Then reference static assets with the /static/ URL prefix." (push (hunchentoot:create-folder-dispatcher-and-handler "/static/" (merge-pathnames "src/static" ;; starts without a / (asdf:system-source-directory :myproject))) ;; &lt;- myproject hunchentoot:*dispatch-table*)) and call it in the function that starts your application:</description></item><item><title>Routes and URL parameters</title><link>http://example.org/building-blocks/routing/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/building-blocks/routing/index.html</guid><description>I prefer the easy-routes library than pure Hunchentoot to define routes, as we did in the tutorial, so skip to its section below if you want. However, it can only be benificial to know the built-in Hunchentoot ways.
Info Please see the tutorial where we define routes with path parameters and where we also access URL parameters.
Hunchentoot The dispatch table The first, most basic way in Hunchentoot to create a route is to add a URL -> function association in its “prefix dispatch” table.</description></item><item><title>Templates</title><link>http://example.org/building-blocks/templates/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/building-blocks/templates/index.html</guid><description>Djula - HTML markup Djula is a port of Python’s Django template engine to Common Lisp. It has excellent documentation.
Install it if you didn’t already:
(ql:quickload "djula") The Caveman framework uses it by default, but otherwise it is not difficult to setup. We must declare where our templates live with something like:
(djula:add-template-directory (asdf:system-relative-pathname "myproject" "templates/")) and then we can declare and compile the ones we use, for example::
(defparameter +base.html+ (djula:compile-template* "base.html")) (defparameter +products.html+ (djula:compile-template* "products.html")) A Djula template looks like this:</description></item><item><title>Sessions</title><link>http://example.org/building-blocks/session/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/building-blocks/session/index.html</guid><description>When a web client (a user’s browser) connects to your app, you can start a session with it, and store data, the time of the session.
Hunchentoot uses cookies to store the session ID, and if not possible it rewrites URLs. So, at every subsequent request by this web client, you can check if there is a session data.
You can store any Lisp object in a web session. You only have to:</description></item><item><title>Headers</title><link>http://example.org/building-blocks/headers/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/building-blocks/headers/index.html</guid><description>A quick reference.
These functions have to be used in the context of a web request.
Set headers Use header-out to set headers, like this:
(setf (hunchentoot:header-out "HX-Trigger") "myEvent") This sets the header of the current request.
USe headers-out (plural) to get an association list of headers:
An alist of the outgoing http headers not including the ‘Set-Cookie’, ‘Content-Length’, and ‘Content-Type’ headers. Use the functions HEADER-OUT and (SETF HEADER-OUT) to modify this slot.</description></item><item><title>Errors and interactivity</title><link>http://example.org/building-blocks/errors-interactivity/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/building-blocks/errors-interactivity/index.html</guid><description>In all frameworks, we can choose the level of interactivity.
The web framework can be interactive in different degrees. What should it do when an error happens?
not being interactive: it returns a 404 page and prints the error output on the REPL not interactive but developper friendly: it can show the lisp error message on the HTML page, as well as the full Lisp backtrace it can let the developper have the interactive debugger: in that case the framework doesn’t catch the error, it lets it pass through, and we the developper deal with it as in a normal Slime session. We see this by default:</description></item><item><title>Connecting to a database</title><link>http://example.org/building-blocks/database/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/building-blocks/database/index.html</guid><description>Let’s study different use cases:
do you have an existing database you want to read data from? do you want to create a new database? do you prefer CLOS orientation or to write SQL queries? We have many libraries to work with databases, let’s have a recap first.
The #database section on the awesome-cl list is a resource listing popular libraries to work with different kind of databases. We can group them roughly in those categories:</description></item><item><title>User log-in</title><link>http://example.org/building-blocks/user-log-in/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/building-blocks/user-log-in/index.html</guid><description>How do you check if a user is logged-in, and how do you do the actual log in?
We show an example, without handling passwords yet. See the next section for passwords.
We’ll build a simple log-in page to an admin/ private dashboard.
What do we need to do exactly?</description></item><item><title>Users and passwords</title><link>http://example.org/building-blocks/users-and-passwords/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/building-blocks/users-and-passwords/index.html</guid><description>We don’t know of a Common Lisp framework that will create users and roles for you and protect your routes. You’ll have to either write some Lisp, either use an external tool (such as Keycloak) that will provide all the user management.
Info Stay tuned! We are on to something.
Creating users If you use a database, you’ll have to create at least a users table. It would typically define:</description></item><item><title>Form validation</title><link>http://example.org/building-blocks/form-validation/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/building-blocks/form-validation/index.html</guid><description>We can recommend the clavier library for input validation.
See also the cl-forms library that offers many features:
automatic forms form validation with in-line error messages CSRF protection client-side validation subforms Djula and Spinneret renderers default themes an online demo for you to try etc Get them:
(ql:quickload '(:clavier :cl-forms)) Form validation with the Clavier library Clavier defines validators as class instances. They come in many types, for example the 'less-than, greater-than or len validators. They may take an initialization argument.</description></item><item><title>Running and Building</title><link>http://example.org/building-blocks/building-binaries/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/building-blocks/building-binaries/index.html</guid><description>Running the application from source Info See the tutorial.
To run our Lisp code from source, as a script, we can use the --load switch from our implementation.
We must ensure:
to load the project’s .asd system declaration (if any) to install the required dependencies (this demands we have installed Quicklisp previously) and to run our application’s entry point. So, the recipe to run our project from sources can look like this (you can find such a recipe in our project generator):</description></item><item><title>Deployment</title><link>http://example.org/building-blocks/deployment/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/building-blocks/deployment/index.html</guid><description>How to deploy and monitor a Common Lisp web app?
Info We are re-using content we contributed to the Cookbook.
Deploying manually We can start our executable in a shell and send it to the background (C-z bg), or run it inside a tmux session. These are not the best but hey, it works©.
Here’s a tmux crashcourse:
start a tmux session with tmux inside a session, C-b is tmux’s modifier key. use C-b c to create a new tab, C-b n and C-b p for “next” and “previous” tab/window. use C-b d to detach tmux and come back to your original console. Everything you started in tmux still runs in the background. use C-g to cancel a current prompt (as in Emacs). tmux ls lists the running tmux sessions. tmux attach goes back to a running session. tmux attach -t &lt;name> attaches to the session named “name”. inside a session, use C-b $ to name the current session, so you can see it with tmux ls. Here’s a cheatsheet that was handy.</description></item><item><title>Remote debugging</title><link>http://example.org/building-blocks/remote-debugging/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/building-blocks/remote-debugging/index.html</guid><description>You can have your software running on a machine over the network, connect to it and debug it from home, from your development environment.
You can not only inspect the running program, but also compile and load new code, including installing new libraries, effectively doing hot code reload. It’s up to you to decide to do it or to follow the industry’s best practices. It isn’t because you use Common Lisp that you have to make your deployed program a “big ball of mud”.</description></item><item><title>Electron</title><link>http://example.org/building-blocks/electron/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/building-blocks/electron/index.html</guid><description>Electron is heavy, but really cross-platform, and it has many tools around it. It allows to build releases for the three major OS from your development machine, its ecosystem has tools to handle updates, etc.
Advise: study it before discarding it.
It isn’t however the only portable web view solution. See our next section.
Info This page appeared first on lisp-journey: three web views for Common Lisp, cross-platform GUIs.</description></item><item><title>Web views: cross-platform GUIs</title><link>http://example.org/building-blocks/web-views/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/building-blocks/web-views/index.html</guid><description>Web views are lightweight and cross-platform. They are nowadays a good solution to ship a GUI program to your users.
We present two: WebUI and Webview.h, through CLOG Frame.
Info This page appeared first on lisp-journey: three web views for Common Lisp, cross-platform GUIs.
WebUI WebUI is a new kid in town. It is in development, it has bugs. You can view it as a wrapper around a browser window (or webview.h).</description></item></channel></rss>