var relearn_searchindex = [
  {
    "breadcrumb": "Tutorial part 1",
    "content": "In this application we will:\ndefine a list of products, stored in a dummy database, we’ll have an index page with a search form, we’ll display search results, and have one page per product to see it in details. But everything starts with a project (a system in Lisp parlance) definition.\nSetting up the project Let’s create a regular Common Lisp project.\nWe could start straihgt from the REPL, but we’ll need a project definition to save our project dependencies, and other metadata. Such a project is an ASDF file.\nCreate the file myproject.asd at the project root:\n(asdf:defsystem \"myproject\" :version \"0.1\" :author \"me\" :license \"WTFPL\" :depends-on ( ;; web stack :hunchentoot ;; web server :easy-routes ;; routes facility :djula ;; HTML templates ) :components ((:module \"src\" ;; a src/ subdirectory :components ( (:file \"myproject\") ;; = src/myproject.lisp ))) :description \"A list of products\") Now create a src/ subdirectory, in which you’ll create the one file mentioned in the .asd.\nIn src/myproject.lisp, add this:\n(defpackage myproject (:use :cl)) (in-package :myproject) ;; Here our application code. We created a Lisp package, a namespace if you want, and we made sure that the rest of our code will be written for this package. By default, we are in the cl-user package.\nSometimes the package definition is done in its own packages.lisp file: I like this approach for applications that grow.\nwe are now done with our project skeleton. Let’s compile and load our project and its dependencies.\nStart your editor or a REPL.\nCompile the .asd file with C-c C-k in Slime, or load it with (load \"myproject.asd\") from any REPL.\nAccording you have installed Quicklisp, the library manager, quickload our system:\nCL-USER\u003e (ql:quickload \"myproject\") To load \"myproject\": Load 1 ASDF system: myproject ; Loading \"myproject\" .................................................. [package cl-syntax]............................... [package cl-locale.core].......................... [package cl-locale.reader]........................ [package cl-locale.syntax]........................ [package cl-locale]............................... [package portable-pathnames]...................... [package djula]................................... ... (\"myproject\") We are now ready to write the application logic.\nA list of products Our application will handle hundreds of thousands of products that it gets from a database. For now, we just want a dummy function to return us a list of products, so we can concentrate on the web stack.\nWe’ll write a function that returns n products. Each product is a list of three elements: the product id, its name and a price.\n(in-package :myproject) (defun products (\u0026optional (n 5)) (loop for i from 0 below n collect (list i (format nil \"Product nb ~a\" i) 9.99))) this returns:\n((0 \"Product nb 0\" 9.99) (1 \"Product nb 1\" 9.99) (2 \"Product nb 2\" 9.99) (3 \"Product nb 3\" 9.99) (4 \"Product nb 4\" 9.99)) That’s not much, but that’s enough to show content in a web app, which we’ll do next.",
    "description": "In this application we will:\ndefine a list of products, stored in a dummy database, we’ll have an index page with a search form, we’ll display search results, and have one page per product to see it in details. But everything starts with a project (a system in Lisp parlance) definition.\nSetting up the project Let’s create a regular Common Lisp project.\nWe could start straihgt from the REPL, but we’ll need a project definition to save our project dependencies, and other metadata. Such a project is an ASDF file.",
    "tags": [],
    "title": "Getting Started",
    "uri": "/tutorial/getting-started/index.html"
  },
  {
    "breadcrumb": "Tutorial part 1",
    "content": "It’s time we create a web app!\nOur first route Our very first route will only respond with a “hello world”.\nLet’s start with a couple variables.\n;; still in src/myproject.lisp (defvar *server* nil \"Server instance (Hunchentoot acceptor).\") (defparameter *port* 8899 \"The application port.\") Now hold yourself and let’s write our first route:\n(easy-routes:defroute root (\"/\") () \"hello app\") It only returns a string. We’ll use HTML templates in a second.\nIt’s time to start our web server:\n(defun start-server (\u0026key (port *port*)) (format t \"~\u0026Starting the web server on port ~a~\u0026\" port) (force-output) (setf *server* (make-instance 'easy-routes:easy-routes-acceptor :port port)) (hunchentoot:start *server*)) Compile the whole file with C-c C-k or each individual new variable and function with C-c C-c. Alternatively, you can always do (load \"src/myproject.lisp\") in any REPL. You don’t need to quit and restart the running Lisp image.\nStart the app Now call the function (myproject::start-server) or simply (start-server) if you did the (in-package :myproject) in the REPL.\nYou should see:\nCL-USER\u003e (myproject::start-server ) Starting the web server on port 8899 #\u003cEASY-ROUTES:EASY-ROUTES-ACCEPTOR (host *, port 8899)\u003e So open your browser at localhost:8899/.\nInfo In Slime, the shortcut C-c C-y aka M-x slime-call-defun automatically inserts the function at point in the REPL.\nThat’s how you get a web app running in Common Lisp. The rest is regular web work: HTML templates, forms, etc.\nSo what if we added a bit more of HTML?\nBy the way, did you notice that while developping, you didn’t have to stop the app, to stop the web server, nor to reload anything? Any changes compiled in the running image are immediately available.\nDid you wait for something? You didn’t, and I promise that as the applications grows, with this interactive development style, you will never have to wait for stuff re-compiling or re-loading. You’ll compile your code with a shortcut and have instant feedback. SBCL warns us on bad syntax, undefined variables and other typos, some type mismatches, unreachable code (meaning we might have an issue), etc.\nTo stop the app, use (hunchentoot:stop *server*). You can put this in a “stop-app” function.",
    "description": "It’s time we create a web app!\nOur first route Our very first route will only respond with a “hello world”.\nLet’s start with a couple variables.\n;; still in src/myproject.lisp (defvar *server* nil \"Server instance (Hunchentoot acceptor).\") (defparameter *port* 8899 \"The application port.\") Now hold yourself and let’s write our first route:\n(easy-routes:defroute root (\"/\") () \"hello app\") It only returns a string. We’ll use HTML templates in a second.",
    "tags": [],
    "title": "the first route",
    "uri": "/tutorial/first-route/index.html"
  },
  {
    "breadcrumb": "Tutorial part 1",
    "content": "Our route only returns a string:\n(easy-routes:defroute root (\"/\") () \"hello app\") Can we have it return a template?\nWe’ll use Djula HTML templates.\nUsually, templates go into their templates/ directory. But, we will start out by defining our first template inside our .lisp file:\n;; scr/myproject.lisp (defparameter *template-root* \" \u003ctitle\u003e Lisp web app \u003c/title\u003e \u003cbody\u003e hello app \u003c/body\u003e \") Compile this variable as you go, with C-c C-c (or call again load from any REPL).\nNow come back to the root route. We have to change it. Instead of “hello app”, we use Djula to:\ncompile our string to a Djula template: djula:compile-string render the template: djula:render-template* So let’s do it:\n(easy-routes:defroute root (\"/\" :method :get) () (djula:render-template* (djula:compile-string *template-root*) nil)) The nil argument means “return a string” (as in (format nil …)).\nTemplates are most useful when they do conditional logic, inherit from other templates and are given arguments. So, how could we render a list of products?\nRender products The Djula iteration tag is {% for … in … %} … {% endfor %}. Shall we try it to display a list of products?\nAs a reminder: our products can be retrieved with (products).\nHow well do you know HTML? Nothing’s fancy here. It’s actually boring technology.\n(defparameter *template-root* \" \u003ctitle\u003e Lisp web app \u003c/title\u003e \u003cbody\u003e \u003cul\u003e {% for product in products %} \u003cli\u003e {{ product.1 }} - {{ product.2 }} \u003c/li\u003e {% endfor %} \u003c/ul\u003e \u003c/body\u003e \") re-compile the variabe when done (C-c C-c).\nDo you wonder what’s product.1? Recall that each product is a list of 3 three elements, so we access the element 1 of a product, which is its title. If our product had been a hash-table with a title key, we could have written {{ product.title }}. If the product had been an object with a title slot, we could have written the same. Djula makes it easy for us to access object properties.\nHow can we tell Djula to take a list of products as parameter? We simply use :key arguments, like this:\n;; in the root route (djula:render-template* (djula:compile-string *template-root*) nil :products (products)) ;; \u003c----- added you can compile the route again and refresh the page at localhost:8899/.\nYou should see a list of products! Like so (with proper HTML bullet points):\n- Product nb 0 - 9.99 - Product nb 1 - 9.99 - Product nb 2 - 9.99 - Product nb 3 - 9.99 - Product nb 4 - 9.99 Cool!\nA first refactor We have a very cool route:\n(easy-routes:defroute root (\"/\" :method :get) () (djula:render-template* (djula:compile-string *template-root*) nil :products (products))) To test it and see its output, we had to re-compile it (OK), and refresh our browser. ARGH! We can do better. It may not look obvious now, but we are already writing business logic inside a web route. We should extract as much logic as possible from the route. It will make everything so much easier to write and test in the long run.\nMy point here is that we have one application function: rendering products. We can have a function for this:\n(defun render-products () (djula:render-template* (djula:compile-string *template-root*) nil :products (products))) (easy-routes:defroute root (\"/\" :method :get) () (render-products)) The benefit is that you can run (render-products) by itself (and very quickly with C-c C-y M-x slime-call-defun) to test it in the REPL, and see the HTML output.\nCL-USER\u003e (in-package :myproject) #\u003cPACKAGE \"MYPROJECT\"\u003e MYPROJECT\u003e (render-products) \" \u003ctitle\u003e Lisp web app \u003c/title\u003e \u003cbody\u003e \u003cul\u003e \u003cli\u003e Product nb 0 - 9.99 \u003c/li\u003e \u003cli\u003e Product nb 1 - 9.99 \u003c/li\u003e \u003cli\u003e Product nb 2 - 9.99 \u003c/li\u003e \u003cli\u003e Product nb 3 - 9.99 \u003c/li\u003e \u003cli\u003e Product nb 4 - 9.99 \u003c/li\u003e \u003c/ul\u003e \u003c/body\u003e \" Now you do you, but you’ve been warned ;) Lisp makes small refactorings easy, so take advantage of it. And keep in mind to separate your application logic from the web shenanigans.\nThat being said, let’s move on. We’ll create a page to see each product and we’ll have more fun with a search form.\nWhole file This is our myproject.lisp file so far:\n(in-package :myproject) (defvar *server* nil \"Server instance (Hunchentoot acceptor).\") (defparameter *port* 8899 \"The application port.\") (defparameter *template-root* \" \u003ctitle\u003e Lisp web app \u003c/title\u003e \u003cbody\u003e \u003cul\u003e {% for product in products %} \u003cli\u003e {{ product.1 }} - {{ product.2 }} \u003c/li\u003e {% endfor %} \u003c/ul\u003e \u003c/body\u003e \") (defun products (\u0026optional (n 5)) (loop for i from 0 below n collect (list i (format nil \"Product nb ~a\" i) 9.99))) (defun render-products () (djula:render-template* (djula:compile-string *template-root*) nil :products (products))) (easy-routes:defroute root (\"/\") () (render-products)) (defun start-server (\u0026key (port *port*)) (format t \"~\u0026Starting the web server on port ~a~\u0026\" port) (force-output) (setf *server* (make-instance 'easy-routes:easy-routes-acceptor :port (or port *port*))) (hunchentoot:start *server*))",
    "description": "Our route only returns a string:\n(easy-routes:defroute root (\"/\") () \"hello app\") Can we have it return a template?\nWe’ll use Djula HTML templates.\nUsually, templates go into their templates/ directory. But, we will start out by defining our first template inside our .lisp file:\n;; scr/myproject.lisp (defparameter *template-root* \" \u003ctitle\u003e Lisp web app \u003c/title\u003e \u003cbody\u003e hello app \u003c/body\u003e \") Compile this variable as you go, with C-c C-c (or call again load from any REPL).",
    "tags": [],
    "title": "the first template",
    "uri": "/tutorial/first-template/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Are you ready to build a web app in Common Lisp?\nIn this first tutorial we will build a simple app that shows a web form that will search and display a list of products.\nIn doing so, we will see many necessary building blocks to write web apps in Lisp:\nhow to start a server how to create routes how to define and use path and URL parameters how to define HTML templates how to run and build the app, from our editor and from the terminal. In doing so, we’ll experience the interactive nature of Common Lisp and we’ll learn important commands: running sbcl from the command line with a couple options, what is load, how to interactively compile our app with a keyboard shortcut, how to structure a project with an .asd definition and a package, etc.\nWe expect that you have Quicklisp installed. If not, please see the Cookbook: getting started.\nNow let’s get started.\nBut beware. There is no going back.\n(look at the menu and don’t miss the small previous-next arrows on the top right)",
    "description": "Are you ready to build a web app in Common Lisp?\nIn this first tutorial we will build a simple app that shows a web form that will search and display a list of products.\nIn doing so, we will see many necessary building blocks to write web apps in Lisp:\nhow to start a server how to create routes how to define and use path and URL parameters how to define HTML templates how to run and build the app, from our editor and from the terminal. In doing so, we’ll experience the interactive nature of Common Lisp and we’ll learn important commands: running sbcl from the command line with a couple options, what is load, how to interactively compile our app with a keyboard shortcut, how to structure a project with an .asd definition and a package, etc.",
    "tags": [],
    "title": "Tutorial part 1",
    "uri": "/tutorial/index.html"
  },
  {
    "breadcrumb": "",
    "content": "In this chapter we’ll create routes, we’ll serve local files and we’ll run more than one web app in the same running image.\nWe’ll use those libraries:\n(ql:quickload '(\"hunchentoot\" \"easy-routes\" \"djula\" \"spinneret\")) Info You can create a web project with our project generator: cl-cookieweb.\nWe will use the Hunchentoot web server, but we should say a few words about Clack too.\nHunchentoot is\na web server and at the same time a toolkit for building dynamic websites. As a stand-alone web server, Hunchentoot is capable of HTTP/1.1 chunking (both directions), persistent connections (keep-alive), and SSL. It provides facilities like automatic session handling (with and without cookies), logging, customizable error handling, and easy access to GET and POST parameters sent by the client.\nIt is a software written by Edi Weitz (author of the “Common Lisp Recipes” book, of the ubiquitous cl-ppcre library and much more), it is used and proven solid. One can achieve a lot with it, but sometimes with more friction than with a traditional web framework. For example, dispatching a route by the HTTP method is a bit convoluted, one must write a function for the :uri parameter that does the check, when it is a built-in keyword in other frameworks. We will use the easy-routes library for that.\nClack is\na web application environment for Common Lisp inspired by Python’s WSGI and Ruby’s Rack.\nAlso written by a prolific lisper (E. Fukamachi), it actually uses Hunchentoot by default as the server, but thanks to its pluggable architecture one can use another web server, like the asynchronous Woo, built on the libev event loop, maybe “the fastest web server written in any programming language”©.\nWe’ll cite also Wookie, an asynchronous HTTP server, and its companion library cl-async, for general purpose, non-blocking programming in Common Lisp, built on libuv, the backend library in Node.js.\nClack being more recent and less documented, and Hunchentoot a “de-facto standard”, we’ll concentrate on the latter for this guide. Your contributions to add support for Clack are of course welcome.\nWeb frameworks build upon web servers and can provide facilities for common activities in web development, like a templating system, access to a database, session management, or facilities to build a REST api (those are all easy to do from a bare bones Hunchentoot, as you will see). Caveman is the most popular as per the GitHub stars, but not the most capable. Snooze is maybe the most downloaded Common Lisp web server. In this guide we will learn how to use Hunchentoot, with some light libraries on top.\nIn the end, we will introduce Weblocks. It is a venerable Common Lisp web framework that permits to write ajax-based dynamic web applications without writing any JavaScript, nor writing some lisp that would transpile to JavaScript, thanks to its components-based architecture. It is seeing an extensive rewrite and update since 2017. We present it in more details in the “Isomorphic web frameworks” appendix.\nFor a full list of libraries for the web, please see the awesome-cl list #network-and-internet and Cliki.",
    "description": "In this chapter we’ll create routes, we’ll serve local files and we’ll run more than one web app in the same running image.\nWe’ll use those libraries:\n(ql:quickload '(\"hunchentoot\" \"easy-routes\" \"djula\" \"spinneret\")) Info You can create a web project with our project generator: cl-cookieweb.\nWe will use the Hunchentoot web server, but we should say a few words about Clack too.\nHunchentoot is\na web server and at the same time a toolkit for building dynamic websites. As a stand-alone web server, Hunchentoot is capable of HTTP/1.1 chunking (both directions), persistent connections (keep-alive), and SSL. It provides facilities like automatic session handling (with and without cookies), logging, customizable error handling, and easy access to GET and POST parameters sent by the client.",
    "tags": [],
    "title": "Building blocks",
    "uri": "/building-blocks/index.html"
  },
  {
    "breadcrumb": "Building blocks",
    "content": "Before dwelving into web development, we might want to do something simple: serve some files we have on disk.\nServe local files If you followed the tutorial you know that we can create and start a webserver like this:\n(defvar *acceptor* (make-instance 'hunchentoot:easy-acceptor :port 4242)) (hunchentoot:start *acceptor*) We create an instance of easy-acceptor on port 4242 and we start it. We can now access http://127.0.0.1:4242/. You should get a welcome screen with a link to the documentation and logs to the console.\nInfo You can also use Roswell’s http.server from the command line:\n$ ros install roswell/http.server $ ros -s http.server Hunchentoot server is going to start. Listening on 127.0.0.1:5000. By default, Hunchentoot serves the files from the www/ directory in its source tree. Thus, if you go to the source of easy-acceptor (M-. in Slime), which is probably ~/quicklisp/dists/quicklisp/software/hunchentoot-v1.2.38/, you’ll find the root/ directory. It contains:\nan errors/ directory, with the error templates 404.html and 500.html, an img/ directory, an index.html file. To serve another directory, we give the option document-root to easy-acceptor. We can also set the slot with its accessor:\n(setf (hunchentoot:acceptor-document-root *acceptor*) #p\"path/to/www\") Let’s create our index.html first. Put this in a new www/index.html at the current directory (of the lisp repl):\n\u003chtml\u003e \u003chead\u003e \u003ctitle\u003eHello!\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eHello local server!\u003c/h1\u003e \u003cp\u003e We just served our own files. \u003c/p\u003e \u003c/body\u003e \u003c/html\u003e Let’s start a new acceptor on a new port:\n(defvar *my-acceptor* (make-instance 'hunchentoot:easy-acceptor :port 4444 :document-root #p\"www/\")) (hunchentoot:start *my-acceptor*) go to http://127.0.0.1:4444/ and see the difference.\nNote that we just created another web application on a different port on the same lisp image. This is already pretty cool.\nAccess your server from the internet With Hunchentoot we have nothing to do, we can see the server from the internet right away.\nIf you evaluate this on your VPS:\n(hunchentoot:start (make-instance 'hunchentoot:easy-acceptor :port 4242)) You can see it right away on your server’s IP.\nYou can use the :address parameter of Hunchentoot’s easy-acceptor to bind it and restrict it to 127.0.0.1 (or any address) if you wish.\nStop it with (hunchentoot:stop *).\nNow on the next section, we’ll create some routes to build a dynamic website.",
    "description": "Before dwelving into web development, we might want to do something simple: serve some files we have on disk.\nServe local files If you followed the tutorial you know that we can create and start a webserver like this:\n(defvar *acceptor* (make-instance 'hunchentoot:easy-acceptor :port 4242)) (hunchentoot:start *acceptor*) We create an instance of easy-acceptor on port 4242 and we start it. We can now access http://127.0.0.1:4242/. You should get a welcome screen with a link to the documentation and logs to the console.",
    "tags": [],
    "title": "Simple web server",
    "uri": "/building-blocks/simple-web-server/index.html"
  },
  {
    "breadcrumb": "Building blocks",
    "content": "How can we serve static assets?\nRemember from simple web server how Hunchentoot serves files from a www/ directory by default. We can change that.\nHunchentoot Use the create-folder-dispatcher-and-handler prefix directory function.\nFor example:\n(defun serve-static-assets () \"Let Hunchentoot serve static assets under the /src/static/ directory of your :myproject system. Then reference static assets with the /static/ URL prefix.\" (push (hunchentoot:create-folder-dispatcher-and-handler \"/static/\" (asdf:system-relative-pathname :myproject \"src/static/\")) ;; ^^^ starts without a / hunchentoot:*dispatch-table*)) and call it in the function that starts your application:\n(serve-static-assets) Now our project’s static files located under src/static/ are served with the /static/ prefix. Access them like this:\n\u003cimg src=\"/static/img/banner.jpg\" /\u003e or\n\u003cscript src=\"/static/test.js\" type=\"text/javascript\"\u003e\u003c/script\u003e where the file src/static/test.js could be\nconsole.log(\"hello\");",
    "description": "How can we serve static assets?\nRemember from simple web server how Hunchentoot serves files from a www/ directory by default. We can change that.\nHunchentoot Use the create-folder-dispatcher-and-handler prefix directory function.\nFor example:\n(defun serve-static-assets () \"Let Hunchentoot serve static assets under the /src/static/ directory of your :myproject system. Then reference static assets with the /static/ URL prefix.\" (push (hunchentoot:create-folder-dispatcher-and-handler \"/static/\" (asdf:system-relative-pathname :myproject \"src/static/\")) ;; ^^^ starts without a / hunchentoot:*dispatch-table*)) and call it in the function that starts your application:",
    "tags": [],
    "title": "Static assets",
    "uri": "/building-blocks/static/index.html"
  },
  {
    "breadcrumb": "Building blocks",
    "content": "I prefer the easy-routes library than pure Hunchentoot to define routes, as we did in the tutorial, so skip to its section below if you want. However, it can only be benificial to know the built-in Hunchentoot ways.\nInfo Please see the tutorial where we define routes with path parameters and where we also access URL parameters.\nHunchentoot The dispatch table The first, most basic way in Hunchentoot to create a route is to add a URL -\u003e function association in its “prefix dispatch” table.\nTo bind an existing function to a route, we create a “prefix dispatch” that we push onto the *dispatch-table* list:\n(defun hello () (format nil \"Hello, it works!\")) (push (hunchentoot:create-prefix-dispatcher \"/hello\" #'hello) hunchentoot:*dispatch-table*) You just created the /hello route.\nTo create a route with a regexp, we use create-regex-dispatcher, where the url-as-regexp can be a string, an s-expression or a cl-ppcre scanner.\nIf you didn’t already, create an acceptor and start the server:\n(defvar *server* (make-instance 'hunchentoot:easy-acceptor :port 4242)) (hunchentoot:start *server*) and access it on http://localhost:4242/hello.html.\nWe can see logs on the REPL:\n127.0.0.1 - [2018-10-27 23:50:09] \"get / http/1.1\" 200 393 \"-\" \"Mozilla/5.0 (X11; Linux x86_64; rv:58.0) Gecko/20100101 Firefox/58.0\" 127.0.0.1 - [2018-10-27 23:50:10] \"get /img/made-with-lisp-logo.jpg http/1.1\" 200 12583 \"http://localhost:4242/\" \"Mozilla/5.0 (X11; Linux x86_64; rv:58.0) Gecko/20100101 Firefox/58.0\" 127.0.0.1 - [2018-10-27 23:50:10] \"get /favicon.ico http/1.1\" 200 1406 \"-\" \"Mozilla/5.0 (X11; Linux x86_64; rv:58.0) Gecko/20100101 Firefox/58.0\" 127.0.0.1 - [2018-10-27 23:50:19] \"get /hello.html http/1.1\" 200 20 \"-\" \"Mozilla/5.0 (X11; Linux x86_64; rv:58.0) Gecko/20100101 Firefox/58.0\" Easy handlers The second way to create a route is to use the “easy handlers”.\ndefine-easy-handler allows to create a function and to bind it to an uri at once.\nIts form follows\ndefine-easy-handler (function-name :uri \u003cthe uri\u003e …) (parameters as a list) where \u003cthe uri\u003e can be a string or a function.\nExample:\n(hunchentoot:define-easy-handler (say-yo :uri \"/yo\") (name) (setf (hunchentoot:content-type*) \"text/plain\") (format nil \"Hey~@[ ~A~]!\" name)) Visit it at p://localhost:4242/yo and add parameters on the url: http://localhost:4242/yo?name=Alice.\nJust a thought… we didn’t explicitly ask Hunchentoot to add this route to our first acceptor of the port 4242. Let’s try another acceptor (see previous section), on port 4444: http://localhost:4444/yo?name=Bob It works too! Our route was configured for the two “acceptors”, the two web apps. In fact, define-easy-handler accepts an acceptor-names parameter. If you are only working one web app, that’s OK. If you want to create the route for one app only though, you’ll have to use this parameter:\nacceptor-names (which is evaluated) can be a list of symbols which means that the handler will only be returned by DISPATCH-EASY-HANDLERS in acceptors which have one of these names (see ACCEPTOR-NAME). acceptor-names can also be the symbol T which means that the handler will be returned by DISPATCH-EASY-HANDLERS in every acceptor.\nSo, define-easy-handler has the following signature:\ndefine-easy-handler (function-name \u0026key uri acceptor-names default-request-type) (lambda list parameters) It also has a default-parameter-type which we’ll use in a minute to get url parameters.\nThere are also keys to know for the lambda list. Please see the documentation.\nEasy-routes easy-routes is a route handling extension on top of Hunchentoot. It provides:\ndispatch based on HTTP method (otherwise cumbersome in Hunchentoot) arguments extraction from the url path and decorators, which help for wrapping the route with more logic (ensure a user is logged in, define the request content type…). I prefer it to raw Hunchentoot, it is simpler to use.\nTo use it, don’t create a server with hunchentoot:easy-acceptor but with easy-routes:easy-routes-aceptor:\n(setf *server* (make-instance 'easy-routes:easy-routes-acceptor)) Note: there is also routes-acceptor. The difference is that easy-routes-acceptor iterates over Hunchentoot’s *dispatch-table* if no route is found by easy-routes. That allows us, for example, to serve static content the usual way with Hunchentoot.\nThen define a route like this:\n(easy-routes:defroute name (\"/tasks/:id\" :method :get) (debug \u0026get z) (format nil \"we want the task of id: ~a with parameters debug: ~a and z: ~a\" id debug z)) You can try it on routes like /tasks/33?debug=t\u0026z=abc.\nHere, :id captures the path parameter and binds it to the id variable into the route body. debug and \u0026get z define url parameters. With a :post request, we could define \u0026post parameters to extract from the HTTP request body.\nThese parameters can take an :init-form and :parameter-type options as in define-easy-handler. The init form gives a default value if the argument is not supplied, and the parameter type asks Hunchentoot to convert the argument to this given type. For example, defining an :integer will give you an integer and not a string (all URL parameters are given as a string by default, but more on that on the next section).\neasy-routes’ decorators easy-routes provides us with an easy way to call any function before the route body. Following the naming of a popular language, they are called “decorators”.\nIn the end route definitions are only functions, right? Decorators are only functions too, but they are run before the route body.\nRemember the shape of our routes:\n(easy-routes:defroute root (\"/\") () \"hello app\") We add a list of decorators after the \"/\" part, like this:\n(defroute my-protected-route (\"/foo\" :method :get :decorators ((@json))) () \"hello decorated route\") but what is @json? It’s a function:\n(defun @json (next) (setf (hunchentoot:content-type*) \"application/json\") (funcall next)) You can ignore the @ sign, it doesn’t mean anything in Common Lisp (but as it’s part of the function name it can help you reference all your route decorators).\nRoute “decorators” must accept at least one argument: here called next, it is the function that will be called next (so, at one point, our route body) if we want to. Look at (funcall next): our decorator correctly calls it.\nIf you declare a list of decorators, calling “next” will get you through the chain of decorator functions, and finally to the route body (if no “decorator” exited before).\nSo what it is function doing? Keep it mind that it is called in the context of a web request. So we can call hunchentoot:content-type* (note the *, this function is applied on the current web request). We are setting this request’s content-type to application/json.\nYes, you can copy-paste the setf line directly into your function.\nHere’s another “decorator”:\n(defun @auth (next) (let ((user (hunchentoot:session-value 'user))) (if (not user) (hunchentoot:redirect \"/login\") (funcall next)))) Now that’s interesting. It’s doing this:\nit gets a value from the current web session. This can be any Lisp object. if a user was registered in the session, we call the next method to run other decorators and the route body otherwise, we redirect to the login page. We use them in the “User log in” section.\nHere’s another decorator from easy-routes’ README:\n;; Ensure our PostgreSQL database is connected: (defun @db (next) (postmodern:with-connection *db-spec* (funcall next))) See the easy-routes readme for more.\nAccessing GET and POST parameters You probably have nothing to do to get the value of those parameters: if you defined your route with easy-handler or easy-routes:defroute, the URL parameters create local variables in the function body. Very much like the arguments of the defun macro.\nHowever, here’s how to interact more with URL parameters. In particular, we can define the default type of a parameter: they are strings by default, but we can ask to receive an integer.\nHunchentoot and easy-routes URL parameters First of all, note that we can access query parameters anytime with\n(hunchentoot:parameter \"my-param\") It acts on the default *request* object which is passed to all handlers.\nThere is also get-parameter and post-parameter.\nEarlier we saw some key parameters to define-easy-handler. We now introduce default-parameter-type.\nWe defined the following handler:\n(hunchentoot:define-easy-handler (say-yo :uri \"/yo\") (name) (setf (hunchentoot:content-type*) \"text/plain\") (format nil \"Hey ~a!\" name)) The variable name is a string by default. Let’s check it out:\n(hunchentoot:define-easy-handler (say-yo :uri \"/yo\") (name) (setf (hunchentoot:content-type*) \"text/plain\") (format nil \"Hey ~a you are of type ~a\" name (type-of name))) Going to http://localhost:4242/yo?name=Alice returns\nHey Alice you are of type (SIMPLE-ARRAY CHARACTER (5)) To automatically bind it to another type, we use default-parameter-type. It can be one of those simple types:\n'string (default), 'integer, 'character (accepting strings of length 1 only, otherwise it is nil) or 'boolean or a compound list:\n'(:list \u003ctype\u003e) '(:array \u003ctype\u003e) '(:hash-table \u003ctype\u003e) where \u003ctype\u003e is a simple type.",
    "description": "I prefer the easy-routes library than pure Hunchentoot to define routes, as we did in the tutorial, so skip to its section below if you want. However, it can only be benificial to know the built-in Hunchentoot ways.\nInfo Please see the tutorial where we define routes with path parameters and where we also access URL parameters.\nHunchentoot The dispatch table The first, most basic way in Hunchentoot to create a route is to add a URL -\u003e function association in its “prefix dispatch” table.",
    "tags": [],
    "title": "Routes and URL parameters",
    "uri": "/building-blocks/routing/index.html"
  },
  {
    "breadcrumb": "Tutorial part 1",
    "content": "So far we have 1 route that displays all our products.\nWe will make each product line clickable, to open a new page, that will show more details.\nEach product detail will be available on the URL /product/n where n is the product ID.\nAdd links To begin with, let’s add links to the list of products:\n(defparameter *template-root* \" \u003ctitle\u003e Lisp web app \u003c/title\u003e \u003cbody\u003e \u003cul\u003e {% for product in products %} \u003cli\u003e \u003ca href=\\\"/product/{{ product.0 }}\\\"\u003e{{ product.1 }} - {{ product.2 }}\u003c/a\u003e \u003c/li\u003e {% endfor %} \u003c/ul\u003e \u003c/body\u003e \") Carefully observe that, in the href, we had to escape the quotes :/ This is the shortcoming of defining Djula templates as strings in .lisp files. It’s best to move them to their own directory and own files.\nInfo You can also use a triple quotes reader:\n;; after (ql:quickload \"pythonic-string-reader\") (pythonic-string-reader:enable-pythonic-string-syntax) (defparameter *template-root* \"\"\" \u003ca href=\"/product/\"\u003e\u003c/a\u003e \"\"\") However now that you copy-pasted, re-compile the variable, refresh the page, and click on a link: you should get a “Not Found” error.\nWe need to create a new route to handle the /products/n URL.\nPath parameter The n is a path parameter. It is handled by easy-routes with this syntax:\n(easy-routes:defroute product-route (\"/product/:n\") () (format nil \"parameter is: ~a\" n)) Go again to http://localhost:8899/product/0 and you should see:\nparameter is: 0 Perfect.\nInside our route, n is a string. Let’s proove it:\n(easy-routes:defroute product-route (\"/product/:n\") () (format nil \"parameter is: ~a and is of type: ~a\" n (type-of n))) you should see “parameter is: 0 and is of type: (SIMPLE-ARRAY CHARACTER (1))”, and an array of characters is a string.\nWe can parse a string to an integer with parse-integer, but look, Hunchentoot, and by extension easy-routes, have shortcuts where we can specify the type of each path or URL parameter. The parsing is done by them. Let’s try:\n(easy-routes:defroute product-route (\"/product/:n\") (\u0026path (n 'integer)) (format nil \"parameter is: ~a and is of type: ~a\" n (type-of n))) look at (\u0026path (n 'integer)). When I reload the page, I learn that the type-of 0 and 1 is BIT, and that of 3 is (INTEGER 0 4611686018427387903).\nIf I visit the page with the wrong parameter “foo”: http://localhost:8899/product/foo, we get n as NIL. Alright.\nWith that information, let’s return a product’s details.\nShow a product page So what do we need to show a product page?\na route for the product URL (OK) the product ID (OK) get a product object from its ID (you would typically query the database here) a template for the product rendering the template with a given product. Look, we are not doing any error handling and I’m not going to invent useless requirements for this app. Let’s build the simplest functions! Real use cases will come in time.\nCan you come up with a template and the route?\nHere are mine:\n(defparameter *template-product* \" \u003cbody\u003e {{ product }} \u003c/body\u003e \") (defun get-product (n) ;; Query the DB. (list n (format nil \"Product nb ~a\" n) 9.99)) (defun render-product (n) (djula:render-template* (djula:compile-string *template-product*) nil :product (get-product n))) (easy-routes:defroute product-route (\"/product/:n\") (\u0026path (n 'integer)) (render-product n)) yeah I’m just printing the product, as a list, very simply.\nI added a get-product (n) helper function. You should edit products to use it too.\nHowever I don’t like the copy-pasting between render-product and render-products so I’ll fix it. Can you too?\nSmall refactor I came up with one single render function that takes a template as parameter, and as many key arguments as needed, that it passes to djula:render-template*.\n(defun render (template \u0026rest args) (apply #'djula:render-template* (djula:compile-string template) nil args)) (easy-routes:defroute root (\"/\") () (render *template-root* :products (products))) (easy-routes:defroute product-route (\"/product/:n\") (\u0026path (n 'integer)) (render *template-product* :product (get-product n))) That’s better. Usually all my routes have this form: name, arguments, call to some sort of render function with a template and arguments.\nI’d like to carry on with features but let’s have a word about URL parameters.",
    "description": "So far we have 1 route that displays all our products.\nWe will make each product line clickable, to open a new page, that will show more details.\nEach product detail will be available on the URL /product/n where n is the product ID.\nAdd links To begin with, let’s add links to the list of products:\n(defparameter *template-root* \" \u003ctitle\u003e Lisp web app \u003c/title\u003e \u003cbody\u003e \u003cul\u003e {% for product in products %} \u003cli\u003e \u003ca href=\\\"/product/{{ product.0 }}\\\"\u003e{{ product.1 }} - {{ product.2 }}\u003c/a\u003e \u003c/li\u003e {% endfor %} \u003c/ul\u003e \u003c/body\u003e \") Carefully observe that, in the href, we had to escape the quotes :/ This is the shortcoming of defining Djula templates as strings in .lisp files. It’s best to move them to their own directory and own files.",
    "tags": [],
    "title": "the first path parameter",
    "uri": "/tutorial/first-path-parameter/index.html"
  },
  {
    "breadcrumb": "Building blocks",
    "content": "Djula - HTML markup Djula is a port of Python’s Django template engine to Common Lisp. It has excellent documentation.\nInstall it if you didn’t already:\n(ql:quickload \"djula\") The Caveman framework uses it by default, but otherwise it is not difficult to setup. We must declare where our templates live with something like:\n(djula:add-template-directory (asdf:system-relative-pathname \"myproject\" \"templates/\")) and then we can declare and compile the ones we use, for example::\n(defparameter +base.html+ (djula:compile-template* \"base.html\")) (defparameter +products.html+ (djula:compile-template* \"products.html\")) Info If you get an error message when calling add-template-directory like this\nThe value #P\"/home/user/…/project/src/templates/index.html\" is not of type STRING from the function type declaration. [Condition of type TYPE-ERROR] then update your Quicklisp dist or clone Djula in ~/quicklisp/local-projects/.\nA Djula template looks like this:\n{% extends \"base.html\" %} {% block title %} Products page {% endblock %} {% block content %} \u003cul\u003e {% for product in products %} \u003cli\u003e\u003ca href=\"{{ product.id }}\"\u003e{{ product.name }}\u003c/a\u003e\u003c/li\u003e {% endfor %} \u003c/ul\u003e {% endblock %} This template actually inherits a first one, base.html, which can be:\n\u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003clink rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css\"\u003e \u003ctitle\u003e{% block title %} My Lisp app {% endblock %}\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"container\"\u003e {% block content %} {% endblock %} \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e This base template defines two blocks: one for the page title, one for the page content. A template that wants to inherit this base template will use {% extends \"base.html\" %} and replace each blocks with {% block content %} … {‰ endblock %}.\nAt last, to render the template, call djula:render-template* inside a route.\n(easy-routes:defroute root (\"/\" :method :get) () (djula:render-template* +products.html+ nil :products (products) Djula is, along with its companion access library, one of the most downloaded libraries of Quicklisp.\nDjula filters Filters are only waiting for the developers to define their own, so we should have a work about them.\nThey allow to modify how a variable is displayed. Djula comes with a good set of built-in filters and they are well documented. They are not to be confused with tags.\nThey look like this: {{ var | lower }}, where lower is an existing filter, which renders the text into lowercase.\nFilters sometimes take arguments. For example: {{ var | add:2 }} calls the add filter with arguments var and 2.\nMoreover, it is very easy to define custom filters. All we have to do is to use the def-filter macro, which takes the variable as first argument, and which can take more optional arguments.\nIts general form is:\n(def-filter :myfilter-name (var arg) ;; arg is optional (body)) and it is used like this: {{ var | myfilter-name }}.\nHere’s how the add filter is defined:\n(def-filter :add (it n) (+ it (parse-integer n))) Once you have written a custom filter, you can use it right away throughout the application.\nFilters are very handy to move non-trivial formatting or logic from the templates to the backend.\nSpinneret - lispy templates Spinneret is a “lispy” HTML5 generator. It looks like this:\n(with-page (:title \"Home page\") (:header (:h1 \"Home page\")) (:section (\"~A, here is *your* shopping list: \" *user-name*) (:ol (dolist (item *shopping-list*) (:li (1+ (random 10)) item)))) (:footer (\"Last login: ~A\" *last-login*))) I find Spinneret easier to use than the more famous cl-who, but I personnally prefer to use HTML templates.\nSpinneret has nice features under it sleeves:\nit warns on invalid tags and attributes it can automatically number headers, given their depth it pretty prints html per default, with control over line breaks it understands embedded markdown it can tell where in the document a generator function is (see get-html-tag)",
    "description": "Djula - HTML markup Djula is a port of Python’s Django template engine to Common Lisp. It has excellent documentation.\nInstall it if you didn’t already:\n(ql:quickload \"djula\") The Caveman framework uses it by default, but otherwise it is not difficult to setup. We must declare where our templates live with something like:\n(djula:add-template-directory (asdf:system-relative-pathname \"myproject\" \"templates/\")) and then we can declare and compile the ones we use, for example::\n(defparameter +base.html+ (djula:compile-template* \"base.html\")) (defparameter +products.html+ (djula:compile-template* \"products.html\")) Info If you get an error message when calling add-template-directory like this",
    "tags": [],
    "title": "Templates",
    "uri": "/building-blocks/templates/index.html"
  },
  {
    "breadcrumb": "Building blocks",
    "content": "When a web client (a user’s browser) connects to your app, you can start a session with it, and store data, the time of the session.\nHunchentoot uses cookies to store the session ID, and if not possible it rewrites URLs. So, at every subsequent request by this web client, you can check if there is a session data.\nYou can store any Lisp object in a web session. You only have to:\nstart a session with (hunchentoot:start-session) for example, when a user logs in successfully store an object with (setf (hunchentoot:session-value 'key) val) for example, store the username at the log-in and get the object with (hunchentoot:session-value 'key). for example, in any route where you want to check that a user is logged in. If you don’t find a session key you want, you would redirect to the login page. See our example in the next section about log-in.\nReferences https://common-lisp-libraries.readthedocs.io/hunchentoot/#8-session",
    "description": "When a web client (a user’s browser) connects to your app, you can start a session with it, and store data, the time of the session.\nHunchentoot uses cookies to store the session ID, and if not possible it rewrites URLs. So, at every subsequent request by this web client, you can check if there is a session data.\nYou can store any Lisp object in a web session. You only have to:",
    "tags": [],
    "title": "Sessions",
    "uri": "/building-blocks/session/index.html"
  },
  {
    "breadcrumb": "Building blocks",
    "content": "Flash messages are temporary messages you want to show to your users. They should be displayed once, and only once: on a subsequent page load, they don’t appear anymore.\nThey should specially work across route redirects. So, they are typically created in the web session.\nHandling them involves those steps:\ncreate a message in the session have a quick and easy function to do this give them as arguments to the template when rendering it have some HTML to display them in the templates remove the flash messages from the session. Getting started If you didn’t follow the tutorial, quickload those libraries:\n(ql:quickload '(\"hunchentoot\" \"djula\" \"easy-routes\")) We also introduce a local nickname, to shorten the use of hunchentoot to ht:\n(uiop:add-package-local-nickname :ht :hunchentoot) Add this in your .lisp file if you didn’t already, they are typical for our web demos:\n(defparameter *port* 9876) (defvar *server* nil \"Our Hunchentoot acceptor\") (defun start (\u0026key (port *port*)) (format t \"~\u0026Starting the web server on port ~a~\u0026\" port) (force-output) (setf *server* (make-instance 'easy-routes:easy-routes-acceptor :port port)) (ht:start *server*)) (defun stop () (ht:stop *server*)) Create flash messages in the session This is our core function to quickly pile up a flash message to the web session.\nThe important bits are:\nwe ensure to create a web session with ht:start-session. the :flash session object stores a list of flash messages. we decided that a flash messages holds those properties: its type (string) its message (string) (defun flash (type message) \"Add a flash message in the session. TYPE: can be anything as you do what you want with it in the template. Here, it is a string that represents the Bulma CSS class for notifications: is-primary, is-warning etc. MESSAGE: string\" (let* ((session (ht:start-session)) ;; \u003c---- ensure we started a web session (flash (ht:session-value :flash session))) (setf (ht:session-value :flash session) ;; With a cons, REST returns 1 element ;; (when with a list, REST returns a list) (cons (cons type message) flash)))) Now, inside any route, we can call this function to add a flash message to the session:\n(flash \"warning\" \"You are liking Lisp\") It’s easy, it’s handy, mission solved. Next.\nDelete flash messages when they are rendered For this, we use Hunchentoot’s life cycle and CLOS-orientation:\n;; delete flash after it is used. ;; thanks to https://github.com/rudolfochrist/booker/blob/main/app/controllers.lisp for the tip. (defmethod ht:handle-request :after (acceptor request) (ht:delete-session-value :flash)) which means: after we have handled a request, delete the :flash object from the session.\nWarning If your application sends API requests in JavaScript, they can delete flash messages without you noticing. Read more below.\nAn external API request (from the command line for example) is not concerned, as it doesn’t carry Hunchentoot session cookies.\nRender flash messages in templates Set up Djula templates Create a new flash-template.html file.\n(djula:add-template-directory \"./\") (defparameter *flash-template* (djula:compile-template* \"flash-template.html\")) Info You might need to change the current working directory of your Lisp REPL to the directory of your .lisp file, so that djula:compile-template* can find your template. Use the short command ,cd or (swank:set-default-directory \"/home/you/path/to/app/\"). See also asdf:system-relative-pathname system directory.\nHTML template This is our template. We use Bulma CSS to pimp it up and to use its notification blocks.\n\u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e \u003ctitle\u003eWALK - flash messages\u003c/title\u003e \u003c!-- Bulma Version 1--\u003e \u003clink rel=\"stylesheet\" href=\"https://unpkg.com/bulma@1.0.2/css/bulma.min.css\" /\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- START NAV --\u003e \u003cnav class=\"navbar is-white\"\u003e \u003cdiv class=\"container\"\u003e \u003cdiv class=\"navbar-brand\"\u003e \u003ca class=\"navbar-item brand-text\" href=\"#\"\u003e Bulma Admin \u003c/a\u003e \u003cdiv class=\"navbar-burger burger\" data-target=\"navMenu\"\u003e \u003cspan\u003e\u003c/span\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv id=\"navMenu\" class=\"navbar-menu\"\u003e \u003cdiv class=\"navbar-start\"\u003e \u003ca class=\"navbar-item\" href=\"#\"\u003e Home \u003c/a\u003e \u003ca class=\"navbar-item\" href=\"#\"\u003e Orders \u003c/a\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/nav\u003e \u003c!-- END NAV --\u003e \u003cdiv class=\"container\"\u003e \u003cdiv class=\"columns\"\u003e \u003cdiv class=\"column is-6\"\u003e \u003ch3 class=\"title is-4\"\u003e Flash messages. \u003c/h3\u003e \u003cdiv\u003e Click \u003ca href=\"/tryflash/\"\u003e/tryflash/\u003c/a\u003e to access an URL that creates a flash message and redirects you here.\u003c/div\u003e {% for flash in flashes %} \u003cdiv class=\"notification {{ flash.first }}\"\u003e \u003cbutton class=\"delete\"\u003e\u003c/button\u003e {{ flash.rest }} \u003c/div\u003e {% endfor %} \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003cscript\u003e // JS snippet to click the delete button of the notifications. // see https://bulma.io/documentation/elements/notification/ document.addEventListener('DOMContentLoaded', () =\u003e { (document.querySelectorAll('.notification .delete') || []).forEach(($delete) =\u003e { const $notification = $delete.parentNode; $delete.addEventListener('click', () =\u003e { $notification.parentNode.removeChild($notification); }); }); }); \u003c/script\u003e \u003c/html\u003e Look at\n{% for flash in flashes %} where we render our flash messages.\nDjula allows us to write {{ flash.first }} and {{ flash.rest }} to call the Lisp functions on those objects.\nWe must now create a route that renders our template.\nRoutes The /flash/ URL is the demo endpoint:\n(easy-routes:defroute flash-route (\"/flash/\" :method :get) () (djula:render-template* *flash-template* nil :flashes (or (ht:session-value :flash) (list (cons \"is-primary\" \"No more flash messages were found in the session. This is a default notification.\"))))) It is here that we pass the flash messages as a parameter to the template.\nIn your application, you must add this parameter in all the existing routes. To make this easier, you can:\nuse Djula’s default template variables, but our parameters are to be found dynamically in the current request’s session, so we can instead create a “render” function of ours that calls djula:render-template* and always adds the :flash parameter. Use apply: (defun render (template \u0026rest args) (apply #'djula:render-template* template nil ;; All arguments must be in a list. (list* :flashes (or (ht:session-value :flash) (list (cons \"is-primary\" \"No more flash messages were found in the session. This is a default notification.\"))) args))) Finally, this is the route that creates a flash message:\n(easy-routes:defroute flash-redirect-route (\"/tryflash/\") () (flash \"is-warning\" \"This is a warning message held in the session. It should appear only once: reload this page and you won't see the flash message again.\") (ht:redirect \"/flash/\")) Demo Start the app with (start) if you didn’t start Hunchentoot already, otherwise it was enough to compile the new routes.\nYou should see a default notification. Click the “/tryflash/” URL and you’ll see a flash message, that is deleted after use.\nRefresh the page, and you won’t see the flash message again.\nfull code: https://github.com/web-apps-in-lisp/web-apps-in-lisp.github.io/blob/master/content/building-blocks/flash-messages.lisp Discussing: Flash messages and API calls Our :after method on the Hunchentoot request lifecycle will delete flash messages for any request that carries the session cookies. If your application makes API calls, you can use the Fetch method with the {credentials: \"omit\"} parameter:\nfetch(\"http://localhost:9876/api/\", { credentials: \"omit\" }) Otherwise, don’t use this :after method and delete flash messages explicitely in your non-API routes.\nWe could use a macro shortcut for this:\n(defmacro with-flash-messages ((messages) \u0026body body) `(let ((,messages (ht:session-value :flash))) (prog1 (progn ,@body) (ht:delete-session-value :flash)))) Use it like this:\n(easy-routes:defroute flash-route (\"/flash/\" :method :get) () (with-flash-messages (messages) (djula:render-template* *flash-template* nil :flashes (or messages (list (cons \"is-primary\" \"No more flash messages were found in the session. This is a default notification.\")))))) We want our macro to return the result of djula:render-template*, and not the result of ht:delete-session-value, that is nil, hence the “prog1/ progn” dance.",
    "description": "Flash messages are temporary messages you want to show to your users. They should be displayed once, and only once: on a subsequent page load, they don’t appear anymore.\nThey should specially work across route redirects. So, they are typically created in the web session.\nHandling them involves those steps:\ncreate a message in the session have a quick and easy function to do this give them as arguments to the template when rendering it have some HTML to display them in the templates remove the flash messages from the session. Getting started If you didn’t follow the tutorial, quickload those libraries:",
    "tags": [],
    "title": "Flash messages",
    "uri": "/building-blocks/flash-messages/index.html"
  },
  {
    "breadcrumb": "Building blocks",
    "content": "A quick reference.\nThese functions have to be used in the context of a web request.\nSet headers Use header-out to set headers, like this:\n(setf (hunchentoot:header-out \"HX-Trigger\") \"myEvent\") This sets the header of the current request.\nUSe headers-out (plural) to get an association list of headers:\nAn alist of the outgoing http headers not including the ‘Set-Cookie’, ‘Content-Length’, and ‘Content-Type’ headers. Use the functions HEADER-OUT and (SETF HEADER-OUT) to modify this slot.\nGet headers Use the header-in* and headers-in* (plural) function:\nFunction: (header-in* name \u0026optional (request *request*)) Returns the incoming header with name NAME. NAME can be a keyword (recommended) or a string.\nheaders-in*:\nFunction: (headers-in* \u0026optional (request *request*)) Returns an alist of the incoming headers associated with the REQUEST object REQUEST.\nReference Find some more here:\nhttps://common-lisp-libraries.readthedocs.io/hunchentoot/#headers-in_1",
    "description": "A quick reference.\nThese functions have to be used in the context of a web request.\nSet headers Use header-out to set headers, like this:\n(setf (hunchentoot:header-out \"HX-Trigger\") \"myEvent\") This sets the header of the current request.\nUSe headers-out (plural) to get an association list of headers:\nAn alist of the outgoing http headers not including the ‘Set-Cookie’, ‘Content-Length’, and ‘Content-Type’ headers. Use the functions HEADER-OUT and (SETF HEADER-OUT) to modify this slot.",
    "tags": [],
    "title": "Headers",
    "uri": "/building-blocks/headers/index.html"
  },
  {
    "breadcrumb": "Building blocks",
    "content": "In all frameworks, we can choose the level of interactivity.\nThe web framework can be interactive in different degrees. What should it do when an error happens?\nnot being interactive: it returns a 404 page and prints the error output on the REPL not interactive but developper friendly: it can show the lisp error message on the HTML page, as well as the full Lisp backtrace it can let the developper have the interactive debugger: in that case the framework doesn’t catch the error, it lets it pass through, and we the developper deal with it as in a normal Slime session. We see this by default:\nbut we can also show backtraces and augment the data.\nHunchentoot The global variables to set are\n*show-lisp-errors-p*, nil by default *show-lisp-backtraces-p*, t by default (but the backtrace won’t be shown if the previous setting is nil) *catch-errors-p*, t by default, to set to nil to get the interactive debugger. We can see the backtrace on our error page:\n(setf hunchentoot:*show-lisp-errors-p* t) Enhancing the backtrace in the browser We can also the library hunchentoot-errors to augment the data we see in the stacktrace:\nshow the current request (URI, headers…) show the current session (everything you stored in the session) Clack errors When you use the Clack web server, you can use Clack errors, which can also show the backtrace and the session, with a colourful output:\nHunchentoot’s conditions Hunchentoot defines condition classes:\nhunchentoot-warning, the superclass for all warnings hunchentoot-error, the superclass for errors parameter-error bad-request See the (light) documentation: https://edicl.github.io/hunchentoot/#conditions.\nReferences https://lisp-journey.gitlab.io/blog/common-lisp-on-the-web-enrich-your-stacktrace-with-request-and-session-data/",
    "description": "In all frameworks, we can choose the level of interactivity.\nThe web framework can be interactive in different degrees. What should it do when an error happens?\nnot being interactive: it returns a 404 page and prints the error output on the REPL not interactive but developper friendly: it can show the lisp error message on the HTML page, as well as the full Lisp backtrace it can let the developper have the interactive debugger: in that case the framework doesn’t catch the error, it lets it pass through, and we the developper deal with it as in a normal Slime session. We see this by default:",
    "tags": [],
    "title": "Errors and interactivity",
    "uri": "/building-blocks/errors-interactivity/index.html"
  },
  {
    "breadcrumb": "Isomorphic web frameworks",
    "content": "Reblocks is a widgets-based and server-based framework with a built-in ajax update mechanism. It allows to write dynamic web applications without the need to write JavaScript or to write lisp code that would transpile to JavaScript. It is thus super exciting. It isn’t for newcomers however.\nThe Reblocks’s demo we will build is a TODO app:\nNote To install Reblocks, please see its documentation.\nReblocks’ unit of work is the widget. They look like a class definition:\n(defwidget task () ((title :initarg :title :accessor title) (done :initarg :done :initform nil :accessor done))) Then all we have to do is to define the render method for this widget:\n(defmethod render ((task task)) \"Render a task.\" (with-html (:span (if (done task) (with-html (:s (title task))) (title task))))) It uses the Spinneret template engine by default, but we can bind any other one of our choice.\nTo trigger an ajax event, we write lambdas in full Common Lisp:\n... (with-html (:p (:input :type \"checkbox\" :checked (done task) :onclick (make-js-action (lambda (\u0026key \u0026allow-other-keys) (toggle task)))) ... The function make-js-action creates a simple javascript function that calls the lisp one on the server, and automatically refreshes the HTML of the widgets that need it. In our example, it re-renders one task only.\nIs it appealing ? Carry on its quickstart guide.",
    "description": "Reblocks is a widgets-based and server-based framework with a built-in ajax update mechanism. It allows to write dynamic web applications without the need to write JavaScript or to write lisp code that would transpile to JavaScript. It is thus super exciting. It isn’t for newcomers however.\nThe Reblocks’s demo we will build is a TODO app:\nNote To install Reblocks, please see its documentation.",
    "tags": [],
    "title": "Reblocks",
    "uri": "/isomorphic-web-frameworks/weblocks/index.html"
  },
  {
    "breadcrumb": "Tutorial part 1",
    "content": "As of now we can access URLs like these: http://localhost:8899/product/0 where 0 is a path parameter.\nWe will soon need URL parameters so let’s add one to our routes.\nWe want a debug URL parameter that will show us more data. The URL will accept a ?debug=t part.\nWe have this product route:\n(easy-routes:defroute product-route (\"/product/:n\") (\u0026path (n 'integer)) (render *template-product* :product (get-product n))) With or without the \u0026path part, either is good for now, so let’s remove it for clarity:\n(easy-routes:defroute product-route (\"/product/:n\") () (render *template-product* :product (get-product n))) We removed it because it’s as the same place that we will define URL parameters. Let’s add one.\nGET and POST parameters Our route with a debug URL parameter becomes:\n(easy-routes:defroute product-route (\"/product/:n\") (\u0026get debug) (render *template-product* :product (get-product n))) The \u0026get is here to say this parameter is accepted only in GET requests. You can have \u0026post, and you can leave aside the \u0026get or \u0026post for parameters that are always accepted.\nLet’s not parse the value of the debug variable: if it’s present, it’s truthy, and we should display debug information.\nLet’s add logic to the template.\nThe if tag of Djula is of the form: {% if %} … {% else %} … {% endif %}.\nSo:\n{% if debug %} debug info! {% endif %} And pass the variable to the render function:\n(render *template-product* :product (get-product n) :debug debug) Go to http://localhost:8899/product/0?debug=t and you should see\n(0 Product nb 0 9.99) debug info! Can we do something useful? In my apps, printing debug info and the output of describe for some objects turned useful (grab this output with with-output-to-string).\nFull code Our app looks like this:\n(in-package :myproject) (defvar *server* nil \"Server instance (Hunchentoot acceptor).\") (defparameter *port* 8899 \"The application port.\") (defparameter *template-root* \" \u003ctitle\u003e Lisp web app \u003c/title\u003e \u003cbody\u003e \u003cul\u003e {% for product in products %} \u003cli\u003e \u003ca href=\\\"/product/{{ product.0 }}\\\"\u003e{{ product.1 }} - {{ product.2 }}\u003c/a\u003e \u003c/li\u003e {% endfor %} \u003c/ul\u003e \u003c/body\u003e \") (defparameter *template-product* \" \u003cbody\u003e {{ product }} {% if debug %} debug info! {% endif %} \u003c/body\u003e \") (defun get-product (n) (list n (format nil \"Product nb ~a\" n) 9.99)) (defun products (\u0026optional (n 5)) (loop for i from 0 below n collect (get-product i))) (defun render (template \u0026rest args) (apply #'djula:render-template* (djula:compile-string template) nil args)) (easy-routes:defroute root (\"/\") () (render *template-root* :products (products))) (easy-routes:defroute product-route (\"/product/:n\") (\u0026get debug \u0026path (n 'integer)) (render *template-product* :product (get-product n) :debug debug)) (defun start-server (\u0026key (port *port*)) (format t \"~\u0026Starting the web server on port ~a\" port) (force-output) (setf *server* (make-instance 'easy-routes:easy-routes-acceptor :port port)) (hunchentoot:start *server*)) Everything is contained in one file, and we can run everything from sources or we can build a self-contained binary. Pretty cool!\nBefore we do so, we’ll add a great feature: searching for products.",
    "description": "As of now we can access URLs like these: http://localhost:8899/product/0 where 0 is a path parameter.\nWe will soon need URL parameters so let’s add one to our routes.\nWe want a debug URL parameter that will show us more data. The URL will accept a ?debug=t part.\nWe have this product route:\n(easy-routes:defroute product-route (\"/product/:n\") (\u0026path (n 'integer)) (render *template-product* :product (get-product n))) With or without the \u0026path part, either is good for now, so let’s remove it for clarity:",
    "tags": [],
    "title": "the first URL parameter",
    "uri": "/tutorial/first-url-parameters/index.html"
  },
  {
    "breadcrumb": "Building blocks",
    "content": "Let’s study different use cases:\ndo you have an existing database you want to read data from? do you want to create a new database? do you prefer CLOS orientation or to write SQL queries? We have many libraries to work with databases, let’s have a recap first.\nThe #database section on the awesome-cl list is a resource listing popular libraries to work with different kind of databases. We can group them roughly in those categories:\nwrappers to one database engine (cl-sqlite, postmodern, cl-redis, cl-duckdb…), ORMs (Mito), interfaces to several DB engines (cl-dbi, cl-yesql…), lispy SQL syntax (sxql…) in-memory persistent object databases (bknr.datastore, cl-prevalence,…), graph databases in pure Lisp (AllegroGraph, vivace-graph) or wrappers (neo4cl), object stores (cl-store, cl-naive-store…) and other tools (pgloader, which was re-written from Python to Common Lisp). Table of Contents\nConnect Run queries Insert rows User-level API Close connections The Mito ORM How to integrate the databases into the web frameworks Bonus: pimp your SQLite References How to query an existing database Let’s say you have a database called db.db and you want to extract data from it.\nFor our example, quickload this library:\n(ql:quickload \"cl-dbi\") cl-dbi can connect to major database engines: PostGres, SQLite, MySQL.\nOnce cl-dbi is loaded, you can access its functions with the dbi package prefix.\nConnect To connect to a database, use dbi:connect with paramaters the DB type, and its name:\n(defparameter *db-name* \"db.db\") (defvar *connection* nil \"the DB connection\") (defun connect () (if (uiop:file-exists-p *db-name*) (setf *connection* (dbi:connect :sqlite3 :database-name (get-db-name))) (format t \"The DB file ~a does not exist.\" *db-name*))) The available DB drivers are:\n:mysql :sqlite3 :postgres For the username and password, use the key arguments :username and :password.\nWhen you connect for the first time, cl-dbi will automatically quickload another dependency, depending on the driver. We advise to add the relevant one to your list of dependencies in your .asd file (or your binary will chok on a machine without Quicklisp, we learned this the hard way).\n:dbd-sqlite3 :dbd-mysql :dbd-postgres We can now run queries.\nRun queries Running a query is done is 3 steps:\nwrite the SQL query (in a string, with a lispy syntax…) dbi:prepare the query on a DB connection dbi:execute it and dbi:fetch-all results. (defparameter *select-products* \"SELECT * FROM products LIMIT 100\") (dbi:fetch-all (dbi:execute (dbi:prepare *connection* *select-products*))) This returns something like:\n((:|id| 1 :|title| \"Lisp Cookbook\" :|shelf_id| 1 :|tags_id| NIL :|cover_url| \"https://lispcookbook.github.io/cl-cookbook/orly-cover.png\" :|created_at| \"2024-11-07 22:49:23.972522Z\" :|updated_at| \"2024-12-30 20:55:51.044704Z\") (:|id| 2 :|title| \"Common Lisp Recipes\" :|shelf_id| 1 :|tags_id| NIL :|cover_url| \"\" :|created_at| \"2024-12-09 19:37:30.057172Z\" :|updated_at| \"2024-12-09 19:37:30.057172Z\")) We got a list of records where each record is a property list, a list alternating a key (as a keyword) and a value.\nNote how the keywords respect the case of our database fields with the :|id| notation.\nWith arguments, use a ? placeholder in your SQL query and give a list of arguments to dbi:execute:\n(defparameter *select-products* \"SELECT * FROM products WHERE flag = ? OR updated_at \u003e ?\") (let* ((query (dbi:prepare *connection* *select-products*)) (query (dbi:execute query (list 0 \"1984-01-01\")))) ;; \u003c--- list of arguments (loop for row = (dbi:fetch query) while row ;; process \"row\". )) Insert rows (straight from cl-dbi’s documentation)\ndbi:do-sql prepares and executes a single statement. It returns the number of rows affected. It’s typically used for non-SELECT statements.\n(dbi:do-sql *connection* \"INSERT INTO somewhere (flag, updated_at) VALUES (?, NOW())\" (list 0)) User-level API dbi offers more functions to fetch results than fetch-all.\nYou can use fetch to get one result at a time or again do-sql to run any SQL statement.\nconnect [driver-name \u0026 params] =\u003e \u003cdbi-connection\u003e connect-cached [driver-name \u0026 params] =\u003e \u003cdbi-connection\u003e disconnect [\u003cdbi-connection\u003e] =\u003e T or NIL prepare [conn sql] =\u003e \u003cdbi-query\u003e prepare-cached [conn sql] =\u003e \u003cdbi-query\u003e execute [query \u0026optional params] =\u003e something fetch [result] =\u003e a row data as plist fetch-all [result] =\u003e a list of all row data do-sql [conn sql \u0026optional params] list-all-drivers [] =\u003e (\u003cdbi-driver\u003e ..) find-driver [driver-name] =\u003e \u003cdbi-driver\u003e with-transaction [conn] begin-transaction [conn] commit [conn] rollback [conn] ping [conn] =\u003e T or NIL row-count [conn] =\u003e a number of rows modified by the last executed INSERT/UPDATE/DELETE with-connection [connection-variable-name \u0026body body] Close connections You should take care of closing the DB connection.\ndbi has a macro for that:\n(dbi:with-connection (conn :sqlite3 :database-name \"/home/fukamachi/test.db\") (let* ((query (dbi:prepare conn \"SELECT * FROM People\")) (query (dbi:execute query))) (loop for row = (dbi:fetch query) while row do (format t \"~A~%\" row)))) Inside this macro, conn binds to the current connection.\nThere is more but enough, please refer to cl-dbi’s README.\nThe Mito ORM The Mito ORM provides a nice object-oriented way to define schemas and query the database.\nIt supports SQLite3, PostgreSQL and MySQL, it has automatic migrations, db schema versioning, and more features.\nFor example, this is how one can define a user table with two columns:\n(mito:deftable user () ((name :col-type (:varchar 64)) (email :col-type (or (:varchar 128) :null)))) Once we create the table, we can create and insert user rows with methods such as create-dao:\n(mito:create-dao 'user :name \"Eitaro Fukamachi\" :email \"e.arrows@gmail.com\") Once we edit the table definition (aka the class definition), Mito will (by default) automatically migrate it.\nThere is much more to say, but we refer you to Mito’s good documentation and to the Cookbook (links below).\nHow to integrate the databases into the web frameworks The web frameworks / web servers we use in this guide do not need anything special. Just use a DB driver and fetch results in your routes.\nUsing a DB connection per request with dbi:with-connection is a good idea.\nBonus: pimp your SQLite SQLite is a great database. It loves backward compatibility. As such, its default settings may not be optimal for a web application seeing some load. You might want to set some PRAGMA statements (SQLite settings).\nTo set them, look at your DB driver how to run a raw SQL query.\nWith cl-dbi, this would be dbi:do-sql:\n(dbi:do-sql *connection* \"PRAGMA cache_size = -20000;\") Here’s a nice list of pragmas useful for web development:\nhttps://briandouglas.ie/sqlite-defaults/ References CL Cookbook#databases Mito cl-dbi",
    "description": "Let’s study different use cases:\ndo you have an existing database you want to read data from? do you want to create a new database? do you prefer CLOS orientation or to write SQL queries? We have many libraries to work with databases, let’s have a recap first.\nThe #database section on the awesome-cl list is a resource listing popular libraries to work with different kind of databases. We can group them roughly in those categories:",
    "tags": [],
    "title": "Connecting to a database",
    "uri": "/building-blocks/database/index.html"
  },
  {
    "breadcrumb": "Building blocks",
    "content": "How do you check if a user is logged-in, and how do you do the actual log in?\nWe show an example, without handling passwords yet. See the next section for passwords.\nWe’ll build a simple log-in page to an admin/ private dashboard.\nWhat do we need to do exactly?\nwe need a function to get a user by its ID we need a function to check that a password is correct for a given user we need two templates: a login template a template for a logged-in user we need a route and we need to handle a POST request when the log-in is successful, we need to store a user ID in a web session We choose to structure our app with an admin/ URL that will show both the login page or the “dashboard” for logged-in users.\nWe use these libraries:\n(ql:quickload '(\"hunchentoot\" \"djula\" \"easy-routes\")) We still work from inside our :myproject package. You should have this at the top of your file:\n(in-package :myproject) Let’s start with the model functions.\nGet users (defun get-user (name) (list :name name :password \"demo\")) ;; \u003c--- all our passwords are \"demo\" Yes indeed, that’s a dummy function. You will add your own logic later, we focus on the web stack. Here we return a user object, a plist with a name and a password. So to speak.\n(defun valid-user-p (name password) (let ((user (get-user name))) (and user (string= name (getf user :name)) (string= password (getf user :password))))) Look, what if we stored our own name and password in a file? No need of a DB for a personal or a toy web app.\nIn creds.lisp-expr:\n(:name \"me\" :password \"yadadada\") the “.lisp-expr” is just a convention, so that your tools won’t see it as a lisp source.\nRead it back in with uiop:read-file-form:\n(defparameter *me* (uiop:read-file-form \"creds.lisp-expr\")) (getf *me* :name) ;; =\u003e \"me\" Cool? my 2c.\nTemplates: login, welcome For convenience we again define our templates as strings.\n;;; Templates. ;;; XXX: we have to escape the quotes in our string templates. When they are in files we don't. (defparameter *template-login* \" \u003chtml lang=en\u003e \u003chead\u003e \u003cmeta charset=UTF-8\u003e \u003ctitle\u003eLogin\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv\u003e Login form. \u003c/div\u003e \u003cdiv\u003e Any user name is valid. The password is \\\"demo\\\". \u003c/div\u003e {% if error %} \u003cp style=\\\"color: red;\\\"\u003eInvalid username or password\u003c/p\u003e {% endif %} \u003cform method=post action=\\\"/admin/\\\"\u003e \u003cp\u003eUsername: {% if name %} \u003cinput type=text name=name value=\\\"{{ name }}\\\"\u003e {% else %} \u003cinput type=text name=name\u003e {% endif %} \u003cp\u003ePassword: \u003cinput type=password name=password\u003e \u003cp\u003e \u003cinput type=submit value=\\\"Log In\\\"\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e \" ) (defparameter *template-welcome* \" \u003chtml lang=en\u003e \u003chead\u003e \u003cmeta charset=UTF-8\u003e \u003ctitle\u003eWelcome\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eWelcome, {{ name }}!\u003c/h1\u003e \u003cdiv\u003eYou are logged in to your admin dashboard.\u003c/div\u003e \u003ca href=\\\"/admin/logout\\\"\u003eLog out\u003c/a\u003e \u003c/body\u003e \u003c/html\u003e \") Please refer to the demo to understand how we use them (and their shortcomings). We need the render function (see also the full code below).\nViews: are we logged in? You can start with this route:\n(defun loggedin-p () (hunchentoot:session-value 'name)) ;; GET (easy-routes:defroute admin-route (\"/admin/\" :method :get) () (if (loggedin-p) (render *template-welcome* :name (hunchentoot:session-value 'name)) (render *template-login*)) We are simply querying the session for the user name. If it’s present, that means we have established it at login.\nNow is a great time to use easy-routes’ “decorators” (see the Routing section).\nWe can shorten the route to this:\n(defun @auth (next) (log:info \"checking session\") (if (loggedin-p) (funcall next) (render *template-login*))) ;; GET (easy-routes:defroute admin-route (\"/admin/\" :method :get :decorators ((@auth))) () (render *template-welcome* :name (hunchentoot:session-value 'name))) Yes, ((@auth)) is between 2 (( )) because that will be useful. We can call “decorators” with arguments.\nThe two routes are strictly equivalent, but the second one allows to offload and refactor logic to other functions.\nFirst test Please see the tutorial for how to start a web server.\nIf you compiled the routes while a connection to a web server is active, then your route is accessible.\nVisit http://localhost:8899/admin/, you should see the login form.\nWe didn’t handle the POST request yet.\nlogin: POST request ;; POST (easy-routes:defroute admin-route/POST (\"/admin/\" :method :post) (name password) (cond ((valid-user-p name password) (hunchentoot:start-session) (setf (hunchentoot:session-value 'name) name) (render *template-welcome* :name name)) (t (render *template-login* :name name :error t)))) Beware of this gotcha: the route names must be unique. Otherwise, you will override your previous route definition. We name it admin-route/POST.\nOur login HTML defines two inputs:\n\u003cinput type=text name=name\u003e \u003cinput type=text name=password\u003e that’s why we declared those as POST parameters in the route with (name password).\nOur valid-user-p function only checks that the password equals “demo”.\nDepending on the result, we display the login page again, with an error message, or we display our welcome page and right before we do these important steps:\nwe start a session and we store our user ID We are logged in o/\nLogout Notice the logout button in the welcome page.\nLet’s define the logout route:\n(hunchentoot:define-easy-handler (logout :uri \"/admin/logout\") () (hunchentoot:delete-session-value 'name) (hunchentoot:redirect \"/admin/\")) We have to delete our user’s ID! That’s the step not to forget.\nWe could also delete the current session object altogether with:\n(hunchentoot:remove-session (hunchentoot:*session*)) that depends if you stored more data. The *session* “global” object is the session in the context of the current request.\nAt last we redirect to the admin/ URL, which is going to check the user ID in the session, which isn’t present anymore, and thus show the login form.\nAnd we’ve gone circle.\nRedirect and generate an URL by name We just used a redirect.\nYou will notice that the routes /admin and /admin/ are different. We set up a quick redirect.\n(hunchentoot:define-easy-handler (admin2 :uri \"/admin\") () (hunchentoot:redirect \"/admin/\")) but wait, did we copy an URL by name? We can instead use\n(easy-routes:genurl 'admin-route) ;; \"/admin/\" We also have genurl* to generate an absolute URL:\n(easy-routes:genurl* 'admin-route) ;; \"http://localhost/admin/\" These functions accept arguments to set the PATH and URL parameters.\nHunchentoot code This is the equivalent Hunchentoot route:\n(hunchentoot:define-easy-handler (admin :uri \"/dashboard/\") (name password) (ecase (hunchentoot:request-method*) (:get (if (loggedin-p) (render *template-welcome*) (render *template-login*))) (:post (cond ((valid-user-p name password) (hunchentoot:start-session) (setf (hunchentoot:session-value 'name) name) (render *template-welcome* :name name)) (t (render *template-login* :name name :error t)))) )) Remarks:\nwe can’t dispatch on the request type, so we use the ecase on request-method* we can’t use “decorators” so we use branching it isn’t very clear but name and password are only used in the POST part. we can also use (hunchentoot:post-parameter \"name\") (the parameter as a string) all this adds nesting in our function but otherwise, it’s pretty similar. Full code (defpackage :myproject (:use :cl)) (in-package :myproject) ;; User-facing paramaters. (defparameter *port* 8899) ;; Internal variables. (defvar *server* nil) ;;; Models. (defun get-user (name) (list :name name :password \"demo\")) ;; \u003c--- all our passwords are \"demo\" (defun valid-user-p (name password) (let ((user (get-user name))) (and user (string= name (getf user :name)) (string= password (getf user :password))))) ;;; Templates. ;;; XXX: we have to escape the quotes in our string templates. When they are in files we don't. (defparameter *template-login* \" \u003chtml lang=en\u003e \u003chead\u003e \u003cmeta charset=UTF-8\u003e \u003ctitle\u003eLogin\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv\u003e Login form. \u003c/div\u003e \u003cdiv\u003e Any user name is valid. The password is \\\"demo\\\". \u003c/div\u003e {% if error %} \u003cp style=\\\"color: red;\\\"\u003eInvalid username or password\u003c/p\u003e {% endif %} \u003cform method=post action=\\\"/admin/\\\"\u003e \u003cp\u003eUsername: {% if name %} \u003cinput type=text name=name value=\\\"{{ name }}\\\"\u003e {% else %} \u003cinput type=text name=name\u003e {% endif %} \u003cp\u003ePassword: \u003cinput type=password name=password\u003e \u003cp\u003e \u003cinput type=submit value=\\\"Log In\\\"\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e \" ) (defparameter *template-welcome* \" \u003chtml lang=en\u003e \u003chead\u003e \u003cmeta charset=UTF-8\u003e \u003ctitle\u003eWelcome\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eWelcome, {{ name }}!\u003c/h1\u003e \u003cdiv\u003eYou are logged in to your admin dashboard.\u003c/div\u003e \u003ca href=\\\"/admin/logout\\\"\u003eLog out\u003c/a\u003e \u003c/body\u003e \u003c/html\u003e \") (defun render (template \u0026rest args) (apply #'djula:render-template* (djula:compile-string template) nil args)) ;; Views. (defun loggedin-p () (hunchentoot:session-value 'name)) (defun @auth (next) (if (loggedin-p) (funcall next) (render *template-login*))) ;; GET (easy-routes:defroute admin-route (\"/admin/\" :method :get :decorators ((@auth))) () (render *template-welcome* :name (hunchentoot:session-value 'name))) ;; POST (easy-routes:defroute admin-route/POST (\"/admin/\" :method :post) (name password) (cond ((valid-user-p name password) (hunchentoot:start-session) (setf (hunchentoot:session-value 'name) name) (render *template-welcome* :name name)) (t (render *template-login* :name name :error t)))) (hunchentoot:define-easy-handler (logout :uri \"/admin/logout\") () (hunchentoot:delete-session-value 'name) (hunchentoot:redirect (easy-routes:genurl 'admin-route))) ;; Server. (defun start-server (\u0026key (port *port*)) (format t \"~\u0026Starting the login demo on port ~a~\u0026\" port) (setf *server* (make-instance 'easy-routes:easy-routes-acceptor :port port)) (hunchentoot:start *server*)) (defun stop-server () (hunchentoot:stop *server*)) Caveman In Caveman, *session* is a hash-table that represents the session’s data. Here are our login and logout functions:\n(defun login (user) \"Log the user into the session\" (setf (gethash :user *session*) user)) (defun logout () \"Log the user out of the session.\" (setf (gethash :user *session*) nil)) We define a simple predicate:\n(defun logged-in-p () (gethash :user cm:*session*)) We don’t know a mechanism as easy-routes’ “decorators” but we define a with-logged-in macro:\n(defmacro with-logged-in (\u0026body body) `(if (logged-in-p) (progn ,@body) (render #p\"login.html\" '(:message \"Please log-in to access this page.\")))) If the user isn’t logged in, there will be nothing stored in the session store, and we render the login page. When all is well, we execute the macro’s body. We use it like this:\n(defroute \"/account/logout\" () \"Show the log-out page, only if the user is logged in.\" (with-logged-in (logout) (render #p\"logout.html\"))) (defroute (\"/account/review\" :method :get) () (with-logged-in (render #p\"review.html\" (list :review (get-review (gethash :user *session*)))))) and so on.",
    "description": "How do you check if a user is logged-in, and how do you do the actual log in?\nWe show an example, without handling passwords yet. See the next section for passwords.\nWe’ll build a simple log-in page to an admin/ private dashboard.\nWhat do we need to do exactly?",
    "tags": [],
    "title": "User log-in",
    "uri": "/building-blocks/user-log-in/index.html"
  },
  {
    "breadcrumb": "Building blocks",
    "content": "We don’t know of a Common Lisp framework that will create users and roles for you and protect your routes all at the same time. We have building blocks but you’ll have to write some glue Lisp code.\nYou can also turn to external tools (such as Keycloak or Tesseral) that will provide all the industrial-grade user management.\nIf you like the Mito ORM, look at mito-auth and mito-email-auth.\nCreating users If you use a database, you’ll have to create at least a users table. It would typically define:\na unique ID (integer, primary key) a name (varchar) an email (varchar) a password (varchar (and encrypted)) optionally, a key to the table listing roles. You can start with this:\nCREATE TABLE users ( id INTEGER PRIMARY KEY, username VARCHAR(255), email VARCHAR(255), password VARCHAR(255), ) You can run this right now with SQLite on the command line:\n$ sqlite3 db.db \"CREATE TABLE users (id INTEGER PRIMARY KEY, username VARCHAR(255), email VARCHAR(255), password VARCHAR(255))\" This creates the database if it doesn’t exist. SQLite reads SQL from the command line.\nCreate users:\n$ sqlite3 db.db \"INSERT INTO users VALUES(1,'Alice','alice@mail','xxx');\" Did it work? Run SELECT * FROM users;.\nEncrypting passwords With cl-bcrypt cl-bcrypt is a password hashing and verification library. It is as simple to use as this:\nCL-USER\u003e (defparameter *password* (bcrypt:make-password \"my-secret-password\")) *PASSWORD* and you can specify another salt, another cost factor and another algorithm identifier.\nThen you can use bcrypt:encode to get a string reprentation of the password:\nCL-USER\u003e (bcrypt:encode *password*) \"$2a$16$ClVzMvzfNyhFA94iLDdToOVeApbDppFru3JXNUyi1y1x6MkO0KzZa\" and you decode a password with decode.\nManually (with Ironclad) In this recipe we do the encryption and verification ourselves. We use the de-facto standard Ironclad cryptographic toolkit and the Babel charset encoding/decoding library.\nThe following snippet creates the password hash that should be stored in your database. Note that Ironclad expects a byte-vector, not a string.\n(defun password-hash (password) (ironclad:pbkdf2-hash-password-to-combined-string (babel:string-to-octets password))) pbkdf2 is defined in RFC2898. It uses a pseudorandom function to derive a secure encryption key based on the password.\nThe following function checks if a user is active and verifies the entered password. It returns the user-id if active and verified and nil in all other cases even if an error occurs. Adapt it to your application.\n(defun check-user-password (user password) (handler-case (let* ((data (my-get-user-data user)) (hash (my-get-user-hash data)) (active (my-get-user-active data))) (when (and active (ironclad:pbkdf2-check-password (babel:string-to-octets password) hash)) (my-get-user-id data))) (condition () nil))) And the following is an example on how to set the password on the database. Note that we use (password-hash password) to save the password. The rest is specific to the web framework and to the DB library.\n(defun set-password (user password) (with-connection (db) (execute (make-statement :update :web_user (set= :hash (password-hash password)) (make-clause :where (make-op := (if (integerp user) :id_user :email) user)))))) Credit: /u/arvid on /r/learnlisp.\nSee also cl-authentic - Password management for Common Lisp (web) applications. [LLGPL][8]. safe password storage: cleartext-free, using your choice of hash algorithm through ironclad, storage in an SQL database, password reset mechanism with one-time tokens (suitable for mailing to users for confirmation), user creation optionally with confirmation tokens (suitable for mailing to users), and more on the awesome-cl list.",
    "description": "We don’t know of a Common Lisp framework that will create users and roles for you and protect your routes all at the same time. We have building blocks but you’ll have to write some glue Lisp code.\nYou can also turn to external tools (such as Keycloak or Tesseral) that will provide all the industrial-grade user management.\nIf you like the Mito ORM, look at mito-auth and mito-email-auth.\nCreating users If you use a database, you’ll have to create at least a users table. It would typically define:",
    "tags": [],
    "title": "Users and passwords",
    "uri": "/building-blocks/users-and-passwords/index.html"
  },
  {
    "breadcrumb": "Building blocks",
    "content": "We can recommend the clavier library for input validation.\nSee also the cl-forms library that offers many features:\nautomatic forms form validation with in-line error messages CSRF protection client-side validation subforms Djula and Spinneret renderers default themes an online demo for you to try etc Get them:\n(ql:quickload '(:clavier :cl-forms)) Form validation with the Clavier library Clavier defines validators as class instances. They come in many types, for example the 'less-than, greater-than or len validators. They may take an initialization argument.\nWe create them with either make-instance + the class name, either with their shortcut:\n(make-instance 'clavier:less-than-validator :number 10) ;; OR (clavier:less-than 10) ;; both return =\u003e #\u003cCLAVIER:LESS-THAN-VALIDATOR {10066FF47B}\u003e Then, validate them by calling clavier:validate with the value to validate:\n(clavier:validate * 9) ;; =\u003e T NIL It return two values: the status, an optional error message.\n(clavier:validate ** 11) ;; =\u003e NIL \"11 is not lower than 10\" It’s also possible to just funcall the validator objects (they are funcallable classes).\nComposing validators You can compose them with boolean logic, using clavier’s ||, \u0026\u0026 operators:\n(defparameter *validator* (clavier:|| (clavier:blank) (clavier:\u0026\u0026 (clavier:is-a-string) (clavier:len :min 10))) \"Allow a blank value. When non blank, validate.\") This validator allows an input to be an empty string, but if it isn’t, it validates it.\n(funcall *validator* \"\") ;; =\u003e T NIL (funcall *validator* \"foo\") ;; =\u003e NIL \"Length of \\\"foo\\\" is less than 10\" List of validators This is the list of available validator classes and their shortcut function.\nSome take an initialization argument. Look at your editor’s tooltip for the function signature.\nequal-to-validator (==) not-equal-to-validator (~=) blank-validator (blank) not-blank-validator (not-blank) true-validator (is-true) false-validator (is-false) type-validator (is-a type) string-validator (is-a-string) boolean-validator (is-a-boolean) integer-validator (is-an-integer) symbol-validator (is-a-symbol) keyword-validator (is-a-keyword) list-validator (is-a-list) function-validator (fn function message) email-validator (valid-email) regex-validator (matches-regex) url-validator (valid-url) datetime-validator (valid-datetime) pathname-validator (valid-pathname) not-validator (~ validator) and-validator (\u0026\u0026 validator1 validator2) or-validator (|| validator1 validator2) one-of-validator (one-of options) less-than-validator (less-than number) greater-than-validator (greater-than number) length-validator (len) :allow-blank (not merged, only in my fork) Validation utils We share some functions we used to complement Clavier or make it more convenient.\nFor example we wanted a shorter construct for this common need seen above of allowing empty strings.\nWe also want a function to validate a list of validators and collect the error messages.\nWe define a validate-all function that takes a list of validators and validates them in turn on object.\nIt recognizes a :allow-blank keyword.\n(defun validate-all (validators object) \"Run all validators in turn. Return two values: the status (boolean), and a list of messages. Allow a keyword validator: :allow-blank. Accepts a blank value. If not blank, validate.\" ;; I wanted this to be part of clavier, but well. ;; https://github.com/mmontone/clavier/pull/10 (let ((messages nil) (valid t)) (loop for validator in validators if (and (eql :allow-blank validator) (str:blankp object)) return t else do (unless (symbolp validator) (multiple-value-bind (status message) (clavier:validate validator object :error-p nil) (unless status (setf valid nil)) (when message (push message messages))))) (values valid (reverse (uiop:ensure-list messages))))) Usage:\n(validate-all (list :allow-blank (clavier:len :min 5)) \"\") T NIL (validate-all (list :allow-blank (clavier:len :min 5)) \"foo\") NIL (\"Length of \\\"foo\\\" is less than 5\") Note that Clavier has a “validator-collection” thing, but not shown in the README, and is in our opininion too verbose in comparison to a simple list.",
    "description": "We can recommend the clavier library for input validation.\nSee also the cl-forms library that offers many features:\nautomatic forms form validation with in-line error messages CSRF protection client-side validation subforms Djula and Spinneret renderers default themes an online demo for you to try etc Get them:\n(ql:quickload '(:clavier :cl-forms)) Form validation with the Clavier library Clavier defines validators as class instances. They come in many types, for example the 'less-than, greater-than or len validators. They may take an initialization argument.",
    "tags": [],
    "title": "Form validation",
    "uri": "/building-blocks/form-validation/index.html"
  },
  {
    "breadcrumb": "Building blocks",
    "content": "To access the body parameters of a PUT request, one must add :PUT to hunchentoot:*methods-for-post-parameters*, which defaults to only (:POST):\n(push :put hunchentoot:*methods-for-post-parameters*) This parameter:\nis a list of the request method types (as keywords) for which Hunchentoot will try to compute POST-PARAMETERS.\nNo such setting is required with Lack and Ningle.",
    "description": "To access the body parameters of a PUT request, one must add :PUT to hunchentoot:*methods-for-post-parameters*, which defaults to only (:POST):\n(push :put hunchentoot:*methods-for-post-parameters*) This parameter:\nis a list of the request method types (as keywords) for which Hunchentoot will try to compute POST-PARAMETERS.\nNo such setting is required with Lack and Ningle.",
    "tags": [],
    "title": "PUT and request parameters",
    "uri": "/building-blocks/put/index.html"
  },
  {
    "breadcrumb": "Building blocks",
    "content": "Running the application from source Info See the tutorial.\nTo run our Lisp code from source, as a script, we can use the --load switch from our implementation.\nWe must ensure:\nto load the project’s .asd system declaration (if any) to install the required dependencies (this demands we have installed Quicklisp previously) and to run our application’s entry point. So, the recipe to run our project from sources can look like this (you can find such a recipe in our project generator):\n;; run.lisp (load \"myproject.asd\") (ql:quickload \"myproject\") (in-package :myproject) (handler-case (myproject::start-app :port (ignore-errors (parse-integer (uiop:getenv \"PROJECT_PORT\")))) (error (c) (format *error-output* \"~\u0026An error occured: ~a~\u0026\" c) (uiop:quit 1))) In addition we have allowed the user to set the application’s port with an environment variable.\nWe can run the file like so:\nsbcl --load run.lisp After loading the project, the web server is started in the background. We are offered the usual Lisp REPL, from which we can interact with the running application.\nWe can also connect to the running application from our preferred editor, from home, and compile the changes in our editor to the running instance. See the following section: connecting to a remote lisp image on the Cookbook.\nBuilding a self-contained executable Info See the tutorial.\nAs for all Common Lisp applications, we can bundle our web app in one single executable, including the assets. It makes deployment very easy: copy it to your server and run it.\n$ ./my-web-app Hunchentoot server is started. Listening on localhost:9003. See this recipe on scripting#for-web-apps.\nAs for any executable, you need this in your .asd file:\n:build-operation \"program-op\" ;; leave as is :build-pathname \"\u003cbinary-name\u003e\" :entry-point \"\u003cmy-package:main-function\u003e\" and you build the binary with (asdf:make :myproject).\nHowever, you might find that as soon as you start your app, its stops. That happens because the server thread is started in the background, and nothing tells the binary to wait for it. We can simply sleep (for a large-enough amount of time).\n(defun main () (start-app :port 9003) ;; our start-app ;; keep the binary busy in the foreground, for binaries and SystemD. (sleep most-positive-fixnum)) If you want to learn more, see… the Cookbook: scripting, command line arguments, executables.",
    "description": "Running the application from source Info See the tutorial.\nTo run our Lisp code from source, as a script, we can use the --load switch from our implementation.\nWe must ensure:\nto load the project’s .asd system declaration (if any) to install the required dependencies (this demands we have installed Quicklisp previously) and to run our application’s entry point. So, the recipe to run our project from sources can look like this (you can find such a recipe in our project generator):",
    "tags": [],
    "title": "Running and Building",
    "uri": "/building-blocks/building-binaries/index.html"
  },
  {
    "breadcrumb": "Isomorphic web frameworks",
    "content": "CLOG, the Common Lisp Omnificent GUI, follows a GUI paradigm for the web platform. You don’t write nested \u003cdiv\u003e tags, but you place elements on the page. It sends changes to the page you are working on through websockets, as you add or edit functionalities. We can see changes in real time. For example, change a colour:\nCLOG-USER\u003e (setf (background-color *body*) :red) and BAM, it’s red.\nWe can say the CLOG experience is mindblowing.\nWith CLOG, you can easily create games (there is a Snake demo), multiplayer applications (there is a chat demo)… all this by doing everything in the backend, in Common Lisp, with a lot of interactivity under the fingertips.\nMoreover, its API is stable. The author used a similar product built in Ada professionally for a decade, and transitioned to CLOG in Common Lisp.\nSo, how can we build an interactive app with CLOG?\nWe will build a search form that triggers a search to the back-end on key presses, and displays results to users as they type.\nWe do so without writing any JavaScript.\nBefore we do so, we’ll create a list of dummy products, so than we have something to search for.\nModels Let’s create a package for this new app. I’ll “use” functions and macros provided by the :clog package.\n(uiop:define-package :clog-search (:use :cl :clog)) (in-package :clog-search) Please Quickload those libraries:\n(ql:quickload '(:clog :str)) Now let’s create our products. We quickly define a class containing an ID, a title and a price.\n(defclass product () ((id :initarg :id :accessor product-id :type integer :documentation \"Unique ID\") (title :initarg :title :accessor product-title :type string) (price :initarg :price :accessor product-price :type integer))) (defvar *product-id* 1 \"Counter to increment our unique product ID.\") (defparameter *products* '() \"A list of products.\") We are going to create random testing products, so let’s have a couple helpers to create random titles and prices.\n(defun random-price () \"Return an integer between 1 and 10.000 (price is expressed in cents).\" (1+ (random 9999))) (defparameter *title-part-1* (list \"pretty\" \"little\" \"awesome\" \"white\" \"blue\")) (defparameter *title-part-2* (list \"book\" \"car\" \"laptop\" \"travel\" \"screwdiver\")) (defun random-title () (let ((index (random (length *title-part-1*))) (index-2 (random (length *title-part-2*)))) (format nil \"~a ~a\" (elt *title-part-1* index) (elt *title-part-2* index-2)))) try it out:\n(random-title) We get titles like “white book”, “little car”, etc.\nNow, for testing purposes, we create 100 dummy product instances:\n(defun gen-test-products (\u0026optional (nb 100)) (dotimes (i nb) (push (make-instance 'product :id (incf *product-id*) :title (random-title) :price (random-price)) *products*)) *products*) (defun reset-test-products () (setf *products* nil)) Try it and we get:\n*products* (#\u003cPRODUCT {1005B29363}\u003e #\u003cPRODUCT {1005B29113}\u003e #\u003cPRODUCT {1005B28EC3}\u003e #\u003cPRODUCT {1005B28C73}\u003e #\u003cPRODUCT {1005B28A23}\u003e #\u003cPRODUCT {1005B287D3}\u003e …) Implement the print-object method if you want nice-looking product literals. We are not doing it yet, see the Cookbook.\nNow let’s display the products in the browser.\nWe create a couple more utility functions.\nprint-product prints a product to a stream (standard output, a new string, any other stream). We will use it to show products in the browser. You would add HTML markup here.\n(defun print-product (it \u0026optional (stream nil)) \"Print a product title and price on STREAM (return a new string by default).\" (format stream \"~a - ~f~\u0026\" (str:fit 20 (product-title it)) (/ (product-price it) 100))) (defun print-products (products) \"Return a list of products as a string (dummy, for tests purposes).\" (with-output-to-string (s) (format s \"Products:~\u0026\") (dolist (it products) (print-product it s)))) Try them:\nCL-USER\u003e (print-products *products*) \"Products: pretty car - 22.26 awesome travel - 13.87 little screwdiver - 35.6 white laptop - 6.08 little book - 27.57 white laptop - 42.63 blue travel - 93.8 blue car - 29.99 pretty car - 38.95 little screwdiver - 46.99 … Now we need a function to filter our list of products from a given search query:\n(defun search-products (query \u0026optional (products *products*)) \"Search for QUERY in the products' title. This would be a DB call.\" (loop for product in products when (str:containsp (str:downcase query) (str:downcase (product-title product))) collect product)) We use str:containsp, we could have used search seq1 seq2, with a :test #'equalp for case insensitivity.\nWe are ready to build a little web UI.\nCLOG first steps The very first steps you can do to grasp CLOG’s interactive fun is to make changes to a browser window while on the CLOG REPL.\n;; We suppose you did ;; (ql:quickload \"clog\") CL-USER\u003e (in-package clog-user) CLOG-USER\u003e (clog-repl) NOTICE: Running in debug mode. Debugger will be invoked on errors. Specify ':debug nil' to turn it off on remote environments. Hunchentoot server is started. Listening on 0.0.0.0:8080. HTTP listening on : 0.0.0.0:8080 HTML root : /home/vince/quicklisp/dists/quicklisp/software/clog-20241012-git/./static-files/ SSL : no SSL Key File : NIL SSL Cert File : NIL Long poll first : no Boot function added : no Boot html source use : compiled version, when no file Boot js source use : compiled version Boot file for path / : /debug.html \"Use clog-user:*body* to access the clog-repl window.\" New connection id - c25394291973074d81962563fd0affc0 - #\u003cSERVER {100C900E53}\u003e [this opens your browser] CLOG-USER\u003e (setf (background-color *body*) \"red\") CLOG-USER\u003e (create-div *body* :content \"Hello World!\") And voilà. A browser window was opened for you, you set its background to red, you displayed text and you saw the changes as you executed each step.\nYou will find many demos here: https://github.com/rabbibotton/clog/tree/main/tutorial\nYou can run each demo with (clog:run-tutorial 1) (by their number id).\nCreating elements For the following, I invite you to have a look at CLOG’s common elements. For instance:\ncreate-a to create a \u003ca\u003e link target create-button create-div create-dialog close-dialog … create-table … Typically, to create a div on a DOM element, we use create-div.\nThe first thing we want to start our CLOG app is the initialize function. Its signature:\ninitialize (on-new-window-handler \u0026key (host 0.0.0.0) (port 8080) (server hunchentoot) (extended-routing nil) (long-poll-first nil) (boot-file /boot.html) (boot-function nil) (static-boot-html nil) (static-boot-js nil) (static-root (merge-pathnames ./static-files/ (system-source-directory clog)))) Inititalize CLOG on a socket using HOST and PORT to serve BOOT-FILE as the default route to establish web-socket connections and static files located at STATIC-ROOT. […] The following calls our add-products (which we define just below) function with a body (a CLOG object) as argument.\n(defun start-tutorial () \"Start tutorial.\" (initialize 'add-products) (open-browser)) You’ll need to run the (start-tutorial) at some point. We’ll define add-products now.\nOK so what do we want to do? We want to create a search input field, and to display our products below it. When the user types something, we want to immediately filter the products, and re-display them.\nA first version where we only display products would be this:\n(defun add-products (body) (let* ((result-div (create-div body :content \"\"))) (display-products result-div (subseq *products* 0 10)))) We create a \u003cdiv\u003e, we keep a reference to it as result-div, and we pass it as a parameter to the function display-products we define next.\nThis function will create another div for each product to display. It creates those children in the result-div.\n(defun display-products (parent products) \"Display these products in the page. Create a div per product, with a string to present the product. We don't create nice-looking Bulma product cards here.\" (dolist (it products) (create-div parent :content (format nil \"~a - ~a\" (product-id it) (print-product it))))) You can run (start-tutorial) and try. You should see a list of 10 products.\nAdding interactivity: key up event Now we want to handle the interactivity. The event to watch is the key up event. In CLOG, we have the set-on-key-up method. It takes: a CLOG object (the DOM object it watches for events) and a handler function. This function takes two arguments: the parent CLOG object and the event.\nWe augment and replace the add-products function with the one below where:\nwe create the search input with create-form-element and we listen to the “key-up” event. each event executes the lambda function this function clears the current display and re-displays results by calling our handle-filter-product. (defun add-products (body) \"Create the search input and a div to contain the products. Bind the key-up event of the input field to our filter function.\" (let* ((form (create-form body)) (input (create-form-element form :input :name \"query\" :label (create-label form :content \"Filter product: \"))) (result-div (create-div body :content \"\" ))) (set-on-key-up input (lambda (obj event) (format t \":key-up, value: ~a~\u0026\" (value obj)) ; logging (setf (text result-div) \"\") ; this is how we erase the current content. (handle-filter-product result-div obj event))) ;; Initial content. (display-products result-div (subseq *products* 0 10)))) Below is the function that filters the results with our input and redisplays everything. The value of the search input was read with (value obj).\nWe wait for at least 3 characters in the search input before firing a new query.\n(defun handle-filter-product (div obj event) \"Search and redisplay products.\" ;; TODO: wait a little latency (declare (ignorable event)) (let ((query (value obj))) (if (\u003e (length query) 2) (display-products div (clog-search::search-products query)) (print \"waiting for more input\")))) It works \\o/\nThere are some caveats that need to be worked on:\nif you type a search query of 4 letters quickly, our handler waits for an input of at least 2 characters, but it will be fired 2 other times. That will probably fix the blickering. And, as you noticed:\nwe didn’t copy-paste a nice looking HTML template, so we have a bit of work with that :/ This was only an introduction. As we said, CLOG is well suited for a wide range of applications.\nStop the app Use\n(clog:shutdown) Full code ;; (ql:quickload '(:clog :str)) (uiop:define-package :clog-search (:use :cl :clog)) (in-package :clog-search) ;;; Models. (defclass product () ((id :initarg :id :accessor product-id :type integer :documentation \"Unique ID\") (title :initarg :title :accessor product-title :type string) (price :initarg :price :accessor product-price :type integer))) (defvar *product-id* 1 \"Stupid counter to increment our unique product ID. Normally this is given by a DB.\") (defparameter *products* '() \"A list of products.\") (defun random-price () \"Return an integer between 1 and 10.000 (price is expressed in cents).\" (1+ (random 9999))) (defparameter *title-part-1* (list \"pretty\" \"little\" \"awesome\" \"white\" \"blue\")) (defparameter *title-part-2* (list \"book\" \"car\" \"laptop\" \"travel\" \"screwdiver\")) (defun random-title () (let ((index (random (length *title-part-1*))) (index-2 (random (length *title-part-2*)))) (format nil \"~a ~a\" (elt *title-part-1* index) (elt *title-part-2* index-2)))) (defun gen-test-products (\u0026optional (nb 100)) (dotimes (i nb) (push (make-instance 'product :id (incf *product-id*) :title (random-title) :price (random-price)) *products*)) *products*) (defun reset-test-products () (setf *products* nil)) (defun print-product (it \u0026optional (stream nil)) \"Print a product title and price on STREAM (return a new string by default).\" (format stream \"~a - ~f~\u0026\" (str:fit 20 (product-title it)) (/ (product-price it) 100))) (defun print-products (products) \"Return a list of products as a string (dummy, for tests purposes).\" (with-output-to-string (s) (format s \"Products:~\u0026\") (dolist (it products) (print-product it s)))) (defun search-products (query \u0026optional (products *products*)) \"Search for QUERY in the products' title. This would be a DB call.\" (loop for product in products when (str:containsp (str:downcase query) (str:downcase (product-title product))) collect product)) ;;; CLOG (defun start-tutorial () \"Start tutorial.\" (initialize 'add-products) (open-browser)) (defun add-products (body) \"Create the search input and a div to contain the products. Bind the key-up event of the input field to our filter function.\" (let* ((form (create-form body)) (input (create-form-element form :input :name \"query\" :label (create-label form :content \"Filter product: \"))) (result-div (create-div body :content \"\" ))) (set-on-key-up input (lambda (obj event) (format t \":key-up, value: ~a~\u0026\" (value obj)) ; logging (setf (text result-div) \"\") ; this is how we erase the current content. (handle-filter-product result-div obj event))) (display-products result-div *products*))) (defun display-products (parent products) \"Display these products in the page. Create a div per product, with a string to present the product. We don't create nice-looking Bulma product cards here.\" (dolist (it products) (create-div parent :content (format nil \"~a - ~a\" (product-id it) (print-product it))))) (defun handle-filter-product (div obj event) \"Search and redisplay products.\" ;TODO: wait a little latency (declare (ignorable event)) (let ((query (value obj))) (if (\u003e (length query) 2) (display-products div (search-products query)) (print \"waiting for more input\")))) References CLOG: https://rabbibotton.github.io/clog/clog-manual.html",
    "description": "CLOG, the Common Lisp Omnificent GUI, follows a GUI paradigm for the web platform. You don’t write nested \u003cdiv\u003e tags, but you place elements on the page. It sends changes to the page you are working on through websockets, as you add or edit functionalities. We can see changes in real time. For example, change a colour:\nCLOG-USER\u003e (setf (background-color *body*) :red) and BAM, it’s red.\nWe can say the CLOG experience is mindblowing.",
    "tags": [],
    "title": "CLOG",
    "uri": "/isomorphic-web-frameworks/clog/index.html"
  },
  {
    "breadcrumb": "Building blocks",
    "content": "How to deploy and monitor a Common Lisp web app?\nInfo We are re-using content we contributed to the Cookbook.\nDeploying manually We can start our executable in a shell and send it to the background (C-z bg), or run it inside a tmux session. These are not the best but hey, it works©.\nHere’s a tmux crashcourse:\nstart a tmux session with tmux inside a session, C-b is tmux’s modifier key. use C-b c to create a new tab, C-b n and C-b p for “next” and “previous” tab/window. use C-b d to detach tmux and come back to your original console. Everything you started in tmux still runs in the background. use C-g to cancel a current prompt (as in Emacs). tmux ls lists the running tmux sessions. tmux attach goes back to a running session. tmux attach -t \u003cname\u003e attaches to the session named “name”. inside a session, use C-b $ to name the current session, so you can see it with tmux ls. Here’s a cheatsheet that was handy.\nUnfortunately, if your app crashes or if your server is rebooted, your apps will be stopped. We can do better.\nSystemD: daemonizing, restarting in case of crashes, handling logs This is actually a system-specific task. See how to do that on your system.\nMost GNU/Linux distros now come with Systemd, so here’s a little example.\nDeploying an app with Systemd is as simple as writing a configuration file:\n$ emacs -nw /etc/systemd/system/my-app.service [Unit] Description=stupid simple example [Service] WorkingDirectory=/path/to/your/app ExecStart=/usr/local/bin/sthg sthg Type=simple Restart=always RestartSec=10 Then we have a command to start it:\nsudo systemctl start my-app.service a command to check its status:\nsystemctl status my-app.service and Systemd can handle logging (we write to stdout or stderr, it writes logs):\njournalctl -f -u my-app.service and it handles crashes and restarts the app:\nRestart=always and it can start the app after a reboot:\n[Install] WantedBy=basic.target to enable it:\nsudo systemctl enable my-app.service With Docker There are several Docker images for Common Lisp. For example:\nclfoundation’s Docker images with Quicklisp (not enabled by default) 40ants/base-lisp-image is based on Ubuntu LTS and includes SBCL, CCL, Quicklisp, Qlot and Roswell. container-lisp/s2i-lisp is CentOs based and contains the source for building a Quicklisp based Common Lisp application as a reproducible docker image using OpenShift’s source-to-image. Running behind Nginx There is nothing CL-specific to run your Lisp web app behind Nginx. Here’s an example to get you started.\nWe suppose you are running your Lisp app on a web server, with the IP address 1.2.3.4, on the port 8001. Nothing special here. We want to access our app with a real domain name (and eventuall benefit of other Nginx’s advantages, such as rate limiting etc). We bought our domain name and we created a DNS record of type A that links the domain name to the server’s IP address.\nWe must configure our server with Nginx to tell it that all connections coming from “your-domain-name.org”, on port 80, are to be sent to the Lisp app running locally.\nCreate a new file: /etc/nginx/sites-enabled/my-lisp-app.conf and add this proxy directive:\nserver { listen www.your-domain-name.org:80; server_name your-domain-name.org www.your-domain-name.org; # with and without www location / { proxy_pass http://1.2.3.4:8001/; } # Optional: serve static files with nginx, not the Lisp app. location /files/ { proxy_pass http://1.2.3.4:8001/files/; } } Note that on the proxy_pass directive: proxy_pass http://1.2.3.4:8001/; we are using our server’s public IP address. Often, your Lisp webserver such as Hunchentoot directly listens on it. You might want, for security reasons, to run the Lisp app on localhost.\nReload nginx (send the “reload” signal):\n$ nginx -s reload and that’s it: you can access your Lisp app from the outside through http://www.your-domain-name.org.\nDeploying on Heroku, Digital Ocean, OVH, Deploy.sh and other services See:\nheroku-buildpack-common-lisp Platform.sh has Common Lisp support and so has OVH through their Web PaaS partnership. Heliohost offer a free shared hosting solution for Common Lisp. see the Awesome CL list #deploy section for more interface libraries for Kubernetes, OpenShift, AWS, etc. Cloud Init You can take inspiration from this Cloud Init file for SBCL, an init file for providers supporting the cloudinit format (DigitalOcean etc).\nMonitoring See Prometheus.cl for a Grafana dashboard for SBCL and Hunchentoot metrics (memory, threads, requests per second,…).\nSee cl-sentry-client for error reporting.\nReferences https://github.com/CodyReichert/awesome-cl#deployment",
    "description": "How to deploy and monitor a Common Lisp web app?\nInfo We are re-using content we contributed to the Cookbook.\nDeploying manually We can start our executable in a shell and send it to the background (C-z bg), or run it inside a tmux session. These are not the best but hey, it works©.\nHere’s a tmux crashcourse:\nstart a tmux session with tmux inside a session, C-b is tmux’s modifier key. use C-b c to create a new tab, C-b n and C-b p for “next” and “previous” tab/window. use C-b d to detach tmux and come back to your original console. Everything you started in tmux still runs in the background. use C-g to cancel a current prompt (as in Emacs). tmux ls lists the running tmux sessions. tmux attach goes back to a running session. tmux attach -t \u003cname\u003e attaches to the session named “name”. inside a session, use C-b $ to name the current session, so you can see it with tmux ls. Here’s a cheatsheet that was handy.",
    "tags": [],
    "title": "Deployment",
    "uri": "/building-blocks/deployment/index.html"
  },
  {
    "breadcrumb": "Tutorial part 1",
    "content": "Our root page shows a list of products. We want to do better: provide a search form.\nDo you find HTML forms boring, very boring tech? There is no escaping though, you must know the basics. Go read MDN. It’s only later that you’ll have the right to find and use libraries to do them for you.\nA search form Here’s a search form:\n(defparameter *template-root* \" \u003cform action=\\\"/\\\" method=\\\"GET\\\"\u003e \u003cdiv\u003e \u003clabel for=\\\"query\\\"\u003eWhat do you search for?\u003c/label\u003e \u003cinput name=\\\"query\\\" id=\\\"query\\\" placeholder=\\\"Search…\\\" /\u003e \u003c/div\u003e \u003cdiv\u003e \u003cbutton\u003eSearch\u003c/button\u003e \u003c/div\u003e \u003c/form\u003e \") The important elements are the following:\naction points to /: we will re-use our root endpoint to handle the search and show search results. This could be another route. it is very important to use the name=\"query\" attribute, because this is the name of the URL parameter that will be added when you press the validation button. we still had to escape the quotes, but don’t miss our previous tip about that. If you type “two” in the input field and validate the form, a GET request is sent to / with the full URL being: /?query=two.\nAs a consequence, your route should have a parameter named query.\nInfo It’s best to declare your parameters, but rest assured that Hunchentoot allows you to get the value of any URL parameter of the current web request with the function hunchentoot:parameter.\nAdd URL parameters to the route We are re-using our root route.\nSo it now looks like:\n(easy-routes:defroute root (\"/\") (query) Can we proove it works? Let’s show the query string in the template.\nWe add this in the root template:\n{% if query %} \u003cdiv\u003e query is: {{ query }} \u003c/div\u003e {% endif %} and we pass a new argument to render the template:\n(easy-routes:defroute root (\"/\") (query) (render *template-root* :products (products) :query query)) Go to http://localhost:8899/?query=two and you should see:\nquery is: two What do you search for? [ Search… ] [Search] It’s time we do the most interesting part of the app! (I prefer back-end to front-end)\nSearching our products We have a web form that gives us a search string.\nWe have a database with hundreds of thousands of products.\nAll we need is to efficiently filter our data and display a list of results.\nBut web things first, so we’ll first write a very simple prototype.\nOur products are named “product nb …” and we will search for the query string in their names.\nWe can make things a lil’ bit more interesting with this small change:\n(defun get-product (n) (list n (format nil \"Product nb ~r\" n) 9.99)) Did you notice? format … \"~r\" instead of \"~a\", for the Radix directive. It prints numbers in english.\nMYPROJECT\u003e (products) ((0 \"Product nb zero\" 9.99) (1 \"Product nb one\" 9.99) (2 \"Product nb two\" 9.99) (3 \"Product nb three\" 9.99) (4 \"Product nb four\" 9.99)) Now we will simply iterate on this list of products and collect the ones that contain a query string. Our search function will have this signature:\n(defun search-products (products query) How do you do it?\nI did this:\n(defun search-products (products query) (loop for product in products if (search query (second product) :test #'equalp) collect product)) Where search works on two sequences, and for strings don’t forget to specify the :test function, and here equal and string-equal would work but equalp is string insensitive.\nUsage:\nMYPROJECT\u003e (search-products (products) \"on\") ((1 \"Product nb one\" 9.99)) We could use str:containsp with an optional argument :ignore-case t.\nWe could use remove-if and a lambda function, or define a short helper function.\nAnyways. We did some hard work. Let’s show it to the internet!\nDisplay results We must:\nedit our route, to search for products edit our template, to show a list of results Can you do it?\nI did this for the template:\n(defparameter *template-root* \" \u003cform action=\\\"/\\\" method=\\\"GET\\\"\u003e \u003cdiv\u003e \u003clabel for=\\\"query\\\"\u003eWhat do you search for?\u003c/label\u003e \u003cinput name=\\\"query\\\" id=\\\"query\\\" placeholder=\\\"Search…\\\" /\u003e \u003c/div\u003e \u003cdiv\u003e \u003cbutton\u003eSearch\u003c/button\u003e \u003c/div\u003e \u003c/form\u003e {% if query %} \u003cdiv\u003e query is: {{ query }} \u003c/div\u003e \u003cul\u003e {% for product in results %} \u003cli\u003e \u003ca href=\\\"/product/{{ product.0 }}\\\"\u003e{{ product.1 }} - {{ product.2 }}\u003c/a\u003e \u003c/li\u003e {% endfor %} \u003c/ul\u003e {% endif %} \") I used a results variable, which is a list of product objects.\nI did this for the route:\n(easy-routes:defroute root (\"/\") (query) (render *template-root* :results (search-products (products) query) :query query)) Go to http://localhost:8899/?query=two and you should see:\nWhat do you search for? [Search… ] [Search] query is: two * Product nb two - 9.99 (do you like my screencast? It’s made from Emacs’ eww :p )\nCan you feel that the power of the web is at your fingertips?\nBefore we dive into many more topics, I’d like to ensure we know how to run our app, from outside of the comfort of our editor.\nFull code Our app now look like this:\n(in-package :myproject) ;;; Parameters. (defparameter *port* 8899 \"The application port.\") ;;; Internal variables. (defvar *server* nil \"Server instance (Hunchentoot acceptor).\") ;;; Templates. (defparameter *template-root* \" \u003cform action=\\\"/\\\" method=\\\"GET\\\"\u003e \u003cdiv\u003e \u003clabel for=\\\"query\\\"\u003eWhat do you search for?\u003c/label\u003e \u003cinput name=\\\"query\\\" id=\\\"query\\\" placeholder=\\\"Search…\\\" /\u003e \u003c/div\u003e \u003cdiv\u003e \u003cbutton\u003eSearch\u003c/button\u003e \u003c/div\u003e \u003c/form\u003e {% if query %} \u003cdiv\u003e query is: {{ query }} \u003c/div\u003e \u003cul\u003e {% for product in results %} \u003cli\u003e \u003ca href=\\\"/product/{{ product.0 }}\\\"\u003e{{ product.1 }} - {{ product.2 }}\u003c/a\u003e \u003c/li\u003e {% endfor %} \u003c/ul\u003e {% endif %} \") (defparameter *template-product* \" \u003cbody\u003e {{ product }} {% if debug %} debug info! {% endif %} \u003c/body\u003e \") (defun render (template \u0026rest args) (apply #'djula:render-template* (djula:compile-string template) nil args)) ;;; Models. (defun get-product (n) (list n (format nil \"Product nb ~r\" n) 9.99)) (defun products (\u0026optional (n 5)) (loop for i from 0 below n collect (get-product i))) (defun search-products (products query) (loop for product in products if (search query (second product) :test #'equalp) collect product)) ;;; Routes. (easy-routes:defroute root (\"/\") (query) (render *template-root* :results (search-products (products) query) :query query)) (easy-routes:defroute product-route (\"/product/:n\") (\u0026get debug \u0026path (n 'integer)) (render *template-product* :product (get-product n) :debug debug)) (defun start-server (\u0026key (port *port*)) (format t \"~\u0026Starting the web server on port ~a~\u0026\" port) (force-output) (setf *server* (make-instance 'easy-routes:easy-routes-acceptor :port (or port *port*))) (hunchentoot:start *server*)) Do you also clearly see 3 different components in this app? Templates, models, routes.",
    "description": "Our root page shows a list of products. We want to do better: provide a search form.\nDo you find HTML forms boring, very boring tech? There is no escaping though, you must know the basics. Go read MDN. It’s only later that you’ll have the right to find and use libraries to do them for you.\nA search form Here’s a search form:\n(defparameter *template-root* \" \u003cform action=\\\"/\\\" method=\\\"GET\\\"\u003e \u003cdiv\u003e \u003clabel for=\\\"query\\\"\u003eWhat do you search for?\u003c/label\u003e \u003cinput name=\\\"query\\\" id=\\\"query\\\" placeholder=\\\"Search…\\\" /\u003e \u003c/div\u003e \u003cdiv\u003e \u003cbutton\u003eSearch\u003c/button\u003e \u003c/div\u003e \u003c/form\u003e \") The important elements are the following:",
    "tags": [],
    "title": "the first form",
    "uri": "/tutorial/first-form/index.html"
  },
  {
    "breadcrumb": "Building blocks",
    "content": "You can have your software running on a machine over the network, connect to it and debug it from home, from your development environment.\nYou can not only inspect the running program, but also compile and load new code, including installing new libraries, effectively doing hot code reload. It’s up to you to decide to do it or to follow the industry’s best practices. It isn’t because you use Common Lisp that you have to make your deployed program a “big ball of mud”.\nAlso don’t be too afraid, because when you connect to the remote application from your development machine and start writing code, you are writing code on your local files, in your git project. When you compile and load it with the usual shortcuts (C-c C-c), you are sending the changes to the remote app.\nTLDR; local changes, remote execution.\nInfo We are re-using content we contributed to the Cookbook.\nThe steps involved are to start a Swank server on the remote machine (Swank is the backend companion of Slime), create an ssh tunnel and connect to the Swank server from our editor. Then we can browse and evaluate code on the running instance transparently.\nTo test this, let’s define a function that prints forever.\nIf needed, import the dependencies first:\n(ql:quickload '(\"swank\" \"bordeaux-threads\")) ;; a little common lisp swank demo ;; while this program is running, you can connect to it from ;; another terminal or machine ;; and change the definition of doprint to print something else out! (require :swank) (require :bordeaux-threads) (defparameter *counter* 0) (defun dostuff () (format t \"hello world ~a!~%\" *counter*)) (defun runner () (swank:create-server :port 4006 :dont-close t) (format t \"we are past go!~%\") (bt:make-thread (lambda () (loop repeat 5 do (sleep 5) (dostuff) (incf *counter*))) :name \"do-stuff\")) (runner) On the server, we can run this code with\nsbcl --load demo.lisp If you check with (bt:all-threads), you’ll see your Swank server running on port 4006, as well as the other thread ready to do stuff:\n(#\u003cSB-THREAD:THREAD \"do-stuff\" RUNNING {10027CEDC3}\u003e #\u003cSB-THREAD:THREAD \"Swank Sentinel\" waiting on: #\u003cWAITQUEUE {10027D0003}\u003e {10027CE8B3}\u003e #\u003cSB-THREAD:THREAD \"Swank 4006\" RUNNING {10027CEB63}\u003e #\u003cSB-THREAD:THREAD \"main thread\" RUNNING {1007C40393}\u003e) We do port forwarding on our development machine:\nssh -L4006:127.0.0.1:4006 username@example.com this will securely forward port 4006 on the server at example.com to our local computer’s port 4006 (Swank only accepts connections from localhost).\nWe connect to the running Swank with M-x slime-connect, choosing localhost for the host and port 4006.\nWe can write new code:\n(defun dostuff () (format t \"goodbye world ~a!~%\" *counter*)) (setf *counter* 0) and eval it as usual with C-c C-c or M-x slime-eval-region for instance. The output should change.\nThat’s how Ron Garret debugged the Deep Space 1 spacecraft from the earth in 1999:\nWe were able to debug and fix a race condition that had not shown up during ground testing. (Debugging a program running on a $100M piece of hardware that is 100 million miles away is an interesting experience. Having a read-eval-print loop running on the spacecraft proved invaluable in finding and fixing the problem.\nReferences Slime documentation: connecting to a remote Lisp Ron Garret: Lisping at the JPL CL Cookbook: debugging",
    "description": "You can have your software running on a machine over the network, connect to it and debug it from home, from your development environment.\nYou can not only inspect the running program, but also compile and load new code, including installing new libraries, effectively doing hot code reload. It’s up to you to decide to do it or to follow the industry’s best practices. It isn’t because you use Common Lisp that you have to make your deployed program a “big ball of mud”.",
    "tags": [],
    "title": "Remote debugging",
    "uri": "/building-blocks/remote-debugging/index.html"
  },
  {
    "breadcrumb": "Tutorial part 1",
    "content": "Bonus: pimp your CSS Don’t ask a web developer to help you with the look and feel of the app, they will bring in hundreds of megabytes of Nodejs dependencies :S We suggest a (nearly) one-liner to get a decent CSS with no efforts: by using a class-less CSS, such as Pico.\nWe only need to load it in a \u003chead\u003e tag of our app.\nOptionally, we may write one \u003cdiv\u003e with a class=\"container\" attribute, to have better margins.\nSo, for instance:\n(defparameter *template-root* \" \u003chtml\u003e \u003chead\u003e \u003clink rel=\\\"stylesheet\\\" href=\\\"https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css\\\"\u003e \u003c/head\u003e \u003cbody class=\\\"container\\\"\u003e \u003cform action=\\\"/\\\" method=\\\"GET\\\"\u003e \u003cdiv\u003e \u003clabel for=\\\"query\\\"\u003eWhat do you search for?\u003c/label\u003e \u003cinput name=\\\"query\\\" id=\\\"query\\\" placeholder=\\\"Search…\\\" /\u003e \u003c/div\u003e \u003cdiv\u003e \u003cbutton\u003eSearch\u003c/button\u003e \u003c/div\u003e \u003c/form\u003e {% if query %} \u003cdiv\u003e query is: {{ query }} \u003c/div\u003e \u003cul\u003e {% for product in results %} \u003cli\u003e \u003ca href=\\\"/product/{{ product.0 }}\\\"\u003e{{ product.1 }} - {{ product.2 }}\u003c/a\u003e \u003c/li\u003e {% endfor %} \u003c/ul\u003e {% endif %} \u003c/body\u003e \u003c/html\u003e \") Refresh http://localhost:8899/?query=one. Do you enjoy the difference?!\nI see this:\nHowever note how our root template is benefiting from the CSS, and the product page isn’t. The two pages should inherit from a base template. It’s about time we setup our templates in their own directory.",
    "description": "Bonus: pimp your CSS Don’t ask a web developer to help you with the look and feel of the app, they will bring in hundreds of megabytes of Nodejs dependencies :S We suggest a (nearly) one-liner to get a decent CSS with no efforts: by using a class-less CSS, such as Pico.\nWe only need to load it in a \u003chead\u003e tag of our app.\nOptionally, we may write one \u003cdiv\u003e with a class=\"container\" attribute, to have better margins.",
    "tags": [],
    "title": "Bonus: pimp your CSS",
    "uri": "/tutorial/first-bonus-css/index.html"
  },
  {
    "breadcrumb": "Building blocks",
    "content": "Electron is heavy, but really cross-platform, and it has many tools around it. It allows to build releases for the three major OS from your development machine, its ecosystem has tools to handle updates, etc.\nAdvise: study it before discarding it.\nIt isn’t however the only portable web view solution. See our next section.\nInfo This page appeared first on lisp-journey: three web views for Common Lisp, cross-platform GUIs.\nCeramic (old but works) Ceramic is a set of utilities around Electron to help you build an Electron app: download the npm packages, open a browser window, etc.\nHere’s its getting started snippet:\n;; Start the underlying Electron process (ceramic:start) ;; ^^^^^ this here downloads ±200MB of node packages under the hood. ;; Create a browser window (defvar window (ceramic:make-window :url \"https://www.google.com/\" :width 800 :height 600)) ;; Show it (ceramic:show window) When you run (ceramic:bundle :ceramic-hello-world) you get a .tar file with your application, which you can distribute. Awesome!\nBut what if you don’t want to redirect to google.com but open your own app? You just build your web app in CL, run the webserver (Hunchentoot, Clack…) on a given port, and you’ll open localhost:[PORT] in Ceramic/Electron. That’s it.\nCeramic wasn’t updated in five years as of date and it downloads an outdated version of Electron by default (see (defparameter *electron-version* \"5.0.2\")), but you can change the version yourself.\nThe new Neomacs project, a structural editor and web browser, is a great modern example on how to use Ceramic. Give it a look and give it a try!\nWhat Ceramic actually does is abstracted away in the CL functions, so I think it isn’t the best to start with. We can do without it to understand the full process, here’s how.\nCeramic API reference: http://ceramic.github.io/docs/api-reference.html Electron from scratch Here’s our web app embedded in Electron:\nOur steps are the following:\nfollow the Electron installation instructions, build a binary of your Lisp web app, including assets and HTML templates, if any. see this post: https://lisp-journey.gitlab.io/blog/lisp-for-the-web-build-standalone-binaries-foreign-libraries-templates-static-assets/ (the process will be a tad simpler without Djula templates) bundle this binary into the final Electron build. and that’s it. You can also run the Lisp web app from sources, of course, without building a binary, but then you’ll have to ship all the lisp sources.\nmain.js The most important file to an Electron app is the main.js. The one we show below does the following:\nit starts Electron it starts our web application on the side, as a child process, from a binary name, and a port. it shows our child process’ stdout and stderr it opens a browser window to show our app, running on localhost. it handles the close event. Here’s our version.\nconsole.log(`Hello from Electron 👋`) const { app, BrowserWindow } = require('electron') const { spawn } = require('child_process'); // FIXME Suppose we have our app binary at the current directory. // FIXME This is our hard-coded binary name. var binaryPaths = [ \"./openbookstore\", ]; // FIXME Define any arg required for the binary. // This is very specific to the one I built for the example. var binaryArgs = [\"--web\"]; const binaryapp = null; const runLocalApp = () =\u003e { \"Run our binary app locally.\" console.log(\"running our app locally…\"); const binaryapp = spawn(binaryPaths[0], binaryArgs); return binaryapp; } // Start an Electron window. const createWindow = () =\u003e { const win = new BrowserWindow({ width: 800, height: 600, }) // Open localhost on the app's port. // TODO: we should read the port from an environment variable or a config file. // FIXME hard-coded PORT number. win.loadURL('http://localhost:4242/') } // Run our app. let child = runLocalApp(); // We want to see stdout and stderr of the child process // (to see our Lisp app output). child.stdout.on('data', (data) =\u003e { console.log(`stdout:\\n${data}`); }); child.stderr.on('data', (data) =\u003e { console.error(`stderr: ${data}`); }); child.on('error', (error) =\u003e { console.error(`error: ${error.message}`); }); // Handle Electron close events. child.on('close', (code) =\u003e { console.log(`openbookstore process exited with code ${code}`); }); // Open it in Electron. app.whenReady().then(() =\u003e { createWindow(); // Open a window if none are open (macOS) if (process.platform == 'darwin') { app.on('activate', () =\u003e { if (BrowserWindow.getAllWindows().length === 0) createWindow() }) } }) // On Linux and Windows, quit the app main all windows are closed. app.on('window-all-closed', () =\u003e { if (process.platform !== 'darwin') { app.quit(); } }) Run it with npm run start (you also have an appropriate packages.json), this gets you the previous screenshot.\nJS and Electron experts, please criticize and build on it.\nMissing parts\nWe didn’t fully finish the example: we need to automatically bundle the binary into the Electron release.\nThen, if you want to communicate from the Lisp app to the Electron window, and the other way around, you’ll have to use the JavaScript layers. Ceramic might help here.\nWhat about Tauri? Bundling an app with Tauri will, AFAIK (I just tried quickly), involve the same steps than with Electron. Tauri might still have less tools for it. You need the Rust toolchain.",
    "description": "Electron is heavy, but really cross-platform, and it has many tools around it. It allows to build releases for the three major OS from your development machine, its ecosystem has tools to handle updates, etc.\nAdvise: study it before discarding it.\nIt isn’t however the only portable web view solution. See our next section.\nInfo This page appeared first on lisp-journey: three web views for Common Lisp, cross-platform GUIs.",
    "tags": [],
    "title": "Electron",
    "uri": "/building-blocks/electron/index.html"
  },
  {
    "breadcrumb": "Tutorial part 1",
    "content": "We have developped a web app in Common Lisp.\nAt the first step, we opened a REPL and since then, without noticing, we have compiled variables and function definitions pieces by pieces, step by step, with keyboard shortcuts giving immediate feedback, testing our progress on the go, running a function in the REPL or refreshing the browser window.\nInfo We didn’t have to restart any Lisp process, nor any web server.\nThink about it, that’s awesome!\n(and yet, we didn’t talk about the interactive debugger and about unwinding the stack to resume from errors)\nHowever, it is useful to start our application from scratch once in a while:\ndid we list all our dependencies in the .asd project definition? does it work from scratch, do we have any issue with fresh data? We can run our app from sources, and we can build a self-contained binary.\nRun from sources Do you remember what we did at the beginning to load our project?\ncompile and load the .asd project definition quickload our project start the web server. That’s all we need. Let’s write these 3 commands in a new file. At the project root, create a file run.lisp, in which you copy those steps:\n;; run.lisp (load \"myproject.asd\") (ql:quickload \"myproject\") (myproject::start-server) Why the double :: in myproject::start-server? Because we didn’t export the start-server function, and because we didn’t write (in-package :myproject).\nThis works too:\n(in-package :myproject) (start-server) Now run the app from the terminal:\nsbcl --load run.lisp or use rlwrap sbcl (a “readline wrapper”) for convenience, to get REPL history and to support the arrow keys. Yeah the default SBCL REPL is barebones.\n“Address in use” error and interactive debugger You should see this output, but you shouldn’t be worried since the error message is explicit:\n$ rlwrap sbcl --load run.lisp This is SBCL 2.1.5, an implementation of ANSI Common Lisp. More information about SBCL is available at \u003chttp://www.sbcl.org/\u003e. SBCL is free software, provided as is, with absolutely no warranty. It is mostly in the public domain; some portions are provided under BSD-style licenses. See the CREDITS and COPYING files in the distribution for more information. To load \"myproject\": Load 1 ASDF system: myproject ; Loading \"myproject\" .............. Starting the web server on port 8899 While evaluating the form starting at line 5, column 0 of #P\"/home/vince/projets/web-apps-in-lisp/walk/walk-book/content/tutorial/run.lisp\": debugger invoked on a USOCKET:ADDRESS-IN-USE-ERROR in thread #\u003cTHREAD \"main thread\" RUNNING {10015484D3}\u003e: Condition USOCKET:ADDRESS-IN-USE-ERROR was signalled. Type HELP for debugger help, or (SB-EXT:EXIT) to exit from SBCL. restarts (invokable by number or by possibly-abbreviated name): 0: [RETRY ] Retry EVAL of current toplevel form. 1: [CONTINUE] Ignore error and continue loading file \"/home/vince/projets/web-apps-in-lisp/walk/walk-book/content/tutorial/run.lisp\". 2: [ABORT ] Abort loading file \"/home/vince/projets/web-apps-in-lisp/walk/walk-book/content/tutorial/run.lisp\". 3: Ignore runtime option --load \"run.lisp\". 4: Skip rest of --eval and --load options. 5: Skip to toplevel READ/EVAL/PRINT loop. 6: [EXIT ] Exit SBCL (calling #'EXIT, killing the process). (USOCKET:SOCKET-LISTEN #(0 0 0 0) 8899 :REUSEADDRESS T :REUSE-ADDRESS NIL :BACKLOG 50 :ELEMENT-TYPE (UNSIGNED-BYTE 8)) source: (ERROR C) 0] What you got here is the interactive debugger with “restart” actions, however presented in a kludgy form. What we get in a good Lisp IDE is way easier to use ;) To exit, read the available restarts, you have two options: type “2” or “6” in the prompt and press Enter. You now get another prompt:\n6 * This is the top-level Lisp REPL. You can type any Lisp forms in there. You can press C-d or type (quit).\nIf you wanted to avoid the debugger, you could use an SBCL switch: --non-interactive. But wait a bit before we use it together please.\nBack to our error message.\nThe meaningful bit is “Condition USOCKET:ADDRESS-IN-USE-ERROR was signalled”. usocket is the low-level library that does the networking for Hunchentoot. “Address in use” is correct: our app is already running from our editor, already using the default port number. We have to either stop the app there, either use another port.\nTo stop the app, use (hunchentoot:stop *server*) in our editor REPL and from within the project package, since *server* is a variable of ours.\nTo use another port, what would you prefer?\nwe can give the port as an argument on the command line, like --port 9000. we can find the next available port. Let’s do the latter.\nFind a port number This will be quick as we’ll use a library for that, called find-port.\nPlease quickload it and add it to the project definition.\nYou can either:\nrun (ql:quickload \"find-port\") on the REPL and add “find-port” in the .asd, in the “:depends-on” list, add “find-port” in the .asd, re-compile it with C-c C-k or a call to load, and then (ql:quickload \"myproject\"). Info You just loaded a new library without needing to restart the lisp process.\nOur .asd file now looks like:\n(asdf:defsystem \"myproject\" :version \"0.1\" :author \"me\" :license \"WTFPL\" :depends-on ( :hunchentoot ;; web server :easy-routes ;; routes facility :djula ;; HTML templates ;; utils :find-port ;; \u003c------- added ) :components ((:module \"src\" ;; a src/ subdirectory :components ( (:file \"myproject\") ;; = src/myproject.lisp ))) :description \"A list of products\") How does find-port work? On the REPL, write (find-port:find-port and look at your editor’s minibuffer, or tooltip, as it should show you the function signature. find-port takes key arguments, :min and :max.\nLet’s try:\nMYPROJECT\u003e (find-port:find-port :min 8899) 8900 That’s all we need to use.\nWhere should we call it, in the run.lisp file or in myproject.lisp?\nWe’ll create a new function in myproject.lisp. We don’t alter the start-server function which does a good job, we’ll create a new function that is responsible of dealing with the outside world.\nLet’s call this function main:\n;; myproject.lisp ;;; Top-level. (defun main () (start-server :port (find-port:find-port :min *port*))) And now we use it in the run.lisp file:\n(load \"myproject.asd\") (ql:quickload \"myproject\") (in-package :myproject) (main) Run it again:\nsbcl --load run.lisp This is SBCL 2.1.5, an implementation of ANSI Common Lisp. More information about SBCL is available at \u003chttp://www.sbcl.org/\u003e. SBCL is free software, provided as is, with absolutely no warranty. It is mostly in the public domain; some portions are provided under BSD-style licenses. See the CREDITS and COPYING files in the distribution for more information. To load \"myproject\": Load 1 ASDF system: myproject ; Loading \"myproject\" .................................................. [package myproject]. Starting the web server on port 8900 * Now the meaningful message is “Starting the web server on port 8900”.\nYou notice this last * thing? Once again, it’s the top-level Lisp prompt. You can type any Lisp form. You can interact with the running web app.\nVisit http://localhost:8900/?query=one, it works!\nYou can see HTTP logs in the console:\n127.0.0.1 - [2025-01-03 13:38:17] \"GET /?query=one HTTP/1.1\" 200 503 \"-\" \"Mozilla/5.0 (X11; Linux x86_64; rv:124.0) Gecko/20100101 Firefox/124.0\" 127.0.0.1 - [2025-01-03 13:38:18] \"GET /favicon.ico HTTP/1.1\" 404 301 \"http://localhost:8900/?query=one\" \"Mozilla/5.0 (X11; Linux x86_64; rv:124.0) Gecko/20100101 Firefox/124.0\" Interact with the running web app * is the Lisp prompt. What is the current package?\nType in\n*package* it responds “#\u003cPACKAGE “COMMON-LISP-USER”\u003e”.\nAre you surprised it isn’t our “myproject” package? I am with you. The explanation is that the in-package we wrote in the run.lisp file is for this file. When SBCL starts up, it starts its top-level evaluator/compiler in the cl-user package. It is asked to load our file, which it does, but once it’s done it’s back at the cl-user package.\nTo facilitate our interactions with the running app, we can of course type right now (in-package :myproject), and we can also add an argument to the command line:\nsbcl --load run.lisp --eval \"(in-package :myproject)\" Ask the value of *package* again. OK.\nWhat can we do more? We can inspect some variables and test some functions. Type in (products), it works. You can check the value of *server*. This is actually useful: we are inspecting the internals of our running web app, and we didn’t need to do anything special. Sure, we can add some logging and a monitoring dashboard. But as a second step.\nWhat can we do more? We can also re-define our functions and variables, or develop our app. Look, we can create a new route. Copy this to the REPL:\n* (easy-routes:defroute hello-route (\"/hello\") () \"hello new route\") HELLO-ROUTE and go to http://localhost:8900/hello: you just created a new route while the app was running.\nBut wait, do we really want to develop our app from this limited terminal REPL? No! If you don’t already, it’s time you understand the usefulness of the load function.\nWhat we want is to edit our .lisp source file, instead of copy-pasting stuff in the REPL, and then to reload the app. The reloading is done with\n* (load \"src/myproject.lisp\") Try it!\nYou can also use ql:quickload.\nIn doing so, you are re-discovering a less interactive way of developping.\nBuilding our first binary Running from sources is OK.\nBuilding a binary requires a bit more work but it can bring advantages:\nthe app will start faster, way faster with a binary (binaries start-up in ±2ms) it may be easier to deploy your app to a server because you don’t need to install a lisp implementation nor to set up Quicklisp on the server. it’s easier to ship your app to end users you can save working versions of your app: binary-v0.1, binary-v0.2 etc. Building binaries with SBCL is done with the function sb-ext:save-lisp-and-die (it lives in the sb-ext SBCL module, that is available by default).\nOther implementations don’t define the exact same function, for instance on Clozure CL the function is ccl:save-application. That’s why we’ll want a compatibility layer to write a portable script across implementations. It is as always provided by ASDF with uiop:dump-image and also with a system declaration in the .asd files.\nSBCL binaries are portable from and to the same operating system: build on GNU/Linux, run on GNU/Linux. Or build on a CI system on the 3 platforms. They are not truly static binaries as they rely on the GLibc. There was an ongoing patch to make them truly static, it isn’t done though.\nAn SBCL binary will weight, by default, around 80MB. With compression, they get to ±20MB. As your application grows, they’ll stay roughly this size. An app of mine, with dozens of dependencies and all the application code, templates and static assets (JS and CSS) is 35MB. LispWorks binaries, reduced in size with their tree shaker, are known to be smaller, a hello world being ±5MB, a web app around 10MB. This tree shaker isn’t in the free version.\nEnough talk, let’s do it. Create a new build.lisp file. We need these steps:\nload our app build a binary where we define an entry point save-lisp-and-die sb-ext:save-lisp-and-die expects these arguments:\na binary name, as a string. a :toplevel key argument, designing the function to run when the binary starts. :executable to set to t if we build an executable, and not a core image. :compression for a compression level (optionnal), and more. We use it like this:\n(sb-ext:save-lisp-and-die \"myproject\" :executable t :toplevel #'myproject::main) This is our build.lisp file:\n(load \"myproject.asd\") (ql:quickload \"myproject\") (sb-ext:save-lisp-and-die \"myproject\" :executable t :toplevel #'myproject::main) Now run it with\nsbcl --load build.lisp You should see:\n$ sbcl --load build.lisp This is SBCL 2.1.5, an implementation of ANSI Common Lisp. More information about SBCL is available at \u003chttp://www.sbcl.org/\u003e. SBCL is free software, provided as is, with absolutely no warranty. It is mostly in the public domain; some portions are provided under BSD-style licenses. See the CREDITS and COPYING files in the distribution for more information. To load \"myproject\": Load 1 ASDF system: myproject ; Loading \"myproject\" ............ [undoing binding stack and other enclosing state... done] [performing final GC... done] [defragmenting immobile space... (fin,inst,fdefn,code,sym)=2118+1401+24925+24417+26979... done] [saving current Lisp image into myproject: writing 0 bytes from the read-only space at 0x50000000 writing 1696 bytes from the static space at 0x50100000 writing 61177856 bytes from the dynamic space at 0x1000000000 writing 2383872 bytes from the immobile space at 0x50200000 writing 16257024 bytes from the immobile space at 0x52a00000 done] it’s done. Run ls on the project root:\n$ ls -lh total 80316 drwxrwxr-x 2 vince vince 4.0K Jan 3 14:35 src -rw-rw-r-- 1 vince vince 133 Jan 3 14:35 build.lisp -rwxr-xr-x 1 vince vince 79M Jan 3 14:29 myproject -rw-rw-r-- 1 vince vince 748 Jan 3 13:36 myproject.asd -rw-rw-r-- 1 vince vince 84 Jan 3 14:35 run.lisp Make the binary executable with chmod + myproject and run it:\n$ ./myproject Starting the web server on port 8900 $ uuuuh does that look like working?\n“The server exits right after start up!” The binary was started, it started our web app correctly, but if we are not mistaken it closed it right away O_o What’s going on?\nThis is a difference from running the app from sources or from a binary:\nfrom sources, and by default, when you run sbcl --load myapp.lisp the myapp.lisp file is loaded and executed, and then we are offered a Lisp REPL (unless we specified --non-interactive). from a binary, we are not offered a Lisp REPL. and that’s good, we are in “production mode” now. We then have to make our web server wait forever.\nJust do this, in the main function:\n(defun main () (start-server :port (find-port:find-port :min *port*)) (sleep most-positive-fixnum)) We are sleeping, I forgot, a few million years. The top-level process is sleeping, but our web server is active in its own thread in the background.\nBuild the binary again, run it again… it works :)\n$ ./myproject Starting the web server on port 8900 127.0.0.1 - [2025-01-03 14:47:40] \"GET /product/1 HTTP/1.1\" 200 54 \"http://localhost:8900/?query=on\" \"Mozilla/5.0 (X11; Linux x86_64; rv:124.0) Gecko/20100101 Firefox/124.0\" If you have a web server, try sending the binary there and run it. The app will be available to the internet, you can access it with your VPS’s IP + the app port. It is possible to set the address of the Hunchentoot acceptor, and to restrict it to localhost, if you wish.\nOnce your app is deployed, there are a couple ways to interact with it while it is running, even from the comfort of your editor, at home (with a Swank server).\nLet’s try the binary compression.\nCore compression Compression is done with zlib. Compression levels are comprised between -1 and 9. There are small differences in the results.\nLet’s try:\n;; build.lisp (sb-ext:save-lisp-and-die \"myproject\" :executable t :toplevel #'myproject::main :compression 9) The build takes a few more seconds. You see:\n[saving current Lisp image into myproject: writing 0 bytes from the read-only space at 0x50000000 compressed 0 bytes into 8 at level 9 writing 1344 bytes from the static space at 0x50100000 compressed 32768 bytes into 422 at level 9 writing 66191360 bytes from the dynamic space at 0x1000000000 … done myproject now weights 19MB.\nBecause we used templates as strings in our lisp files, our binary is self-contained by default, without extra work: it contains the lisp implementation with its compiler and debugger, the libraries (web server and all), the templates. We can easily deploy this app. Congrats!\nClosing words We are only scratching the surface of what we’ll want to do with a real app:\nparse CLI args handle a C-c and other signals read configuration files setup and use a database properly use HTML templates add CSS and other static assets add interactivity on the web page, with or without JavaScript add users login add rights to the routes build a REST API etc We will explore those topics in the other chapters of this guide.\nWe did a great job for a first app:\nwe built a Common Lisp web app we created routes, used path and URL parameters we defined an HTML form we used HTML templates we experienced the interactive nature of Common Lisp we explored how to run, build and ship Common Lisp programs. That’s a lot. You are ready for serious applications now!",
    "description": "We have developped a web app in Common Lisp.\nAt the first step, we opened a REPL and since then, without noticing, we have compiled variables and function definitions pieces by pieces, step by step, with keyboard shortcuts giving immediate feedback, testing our progress on the go, running a function in the REPL or refreshing the browser window.\nInfo We didn’t have to restart any Lisp process, nor any web server.",
    "tags": [],
    "title": "the first build",
    "uri": "/tutorial/first-build/index.html"
  },
  {
    "breadcrumb": "Building blocks",
    "content": "Web views are lightweight and cross-platform. They are nowadays a good solution to ship a GUI program to your users.\nWe present two: WebUI and Webview.h, through CLOG Frame.\nInfo This page appeared first on lisp-journey: three web views for Common Lisp, cross-platform GUIs.\nWebUI WebUI is a new kid in town. It is in development, it has bugs. You can view it as a wrapper around a browser window (or webview.h).\nHowever it is ligthweight, it is easy to build and we have Lisp bindings.\nA few more words about it:\nUse any web browser or WebView as GUI, with your preferred language in the backend and modern web technologies in the frontend, all in a lightweight portable library.\nwritten in pure C one header file multi-platform \u0026 multi-browser opens a real browser (you get the web development tools etc) cross-platform webview we can call JS from Common Lisp, and call Common Lisp from JS. Think of WebUI like a WebView controller, but instead of embedding the WebView controller in your program, which makes the final program big in size, and non-portable as it needs the WebView runtimes. Instead, by using WebUI, you use a tiny static/dynamic library to run any installed web browser and use it as GUI, which makes your program small, fast, and portable. All it needs is a web browser.\nyour program will always run on all machines, as all it needs is an installed web browser.\nSounds compelling right?\nThe other good news is that Common Lisp was one of the first languages it got bindings for. How it happened: I was chating in Discord, mentioned WebUI and BAM! @garlic0x1 developed bindings:\nhttps://github.com/garlic0x1/cl-webui/ thank you so much! (@garlic0x1 has more cool projects on GitHub you can browse. He’s also a contributor to Lem)\nHere’s a simple snippet:\n(defpackage :webui/examples/minimal (:use :cl :webui) (:export :run)) (in-package :webui/examples/minimal) (defun run () (let ((w (webui-new-window))) (webui-show w \"\u003chtml\u003eHello, world!\u003c/html\u003e\") (webui-wait))) I would be the happiest lisper in the world if I didn’t have an annoying issue. See #1. I can run my example just fine, but nothing happens the second time :/ I don’t know if it’s a WebUI thing, the bindings, my system, my build of WebUI… so I’ll give this more time.\nFortunately though, the third solution of this blog post is my favourite! o/\nCLOG Frame (webview.h for all) CLOG Frame is part of the CLOG framework. However, it is not tied to CLOG… nor to Common Lisp!\nCLOG Frame is a short C++ program that builds an executable that takes an URL and a PORT as CLI parameters and opens a webview.h window.\nIt’s easy to build and works just fine. It’s a great approach.\nBack to our matter.\nThis is CLOG Frame: 20 lines!\n#include \u003ciostream\u003e #include \u003csstream\u003e #include \u003cstring\u003e #include \"webview.h\" int main(int argc,char* argv[]) { webview::webview w(true, nullptr); webview::webview *w2 = \u0026w; w.set_title(argv[1]); w.set_size(std::stoi(argv[3]), std::stoi(argv[4]), WEBVIEW_HINT_NONE); w.bind(\"clogframe_quit\", [w2](std::string s) -\u003e std::string { w2-\u003eterminate(); return \"\"; }); std::ostringstream o; o \u003c\u003c \"http://127.0.0.1:\" \u003c\u003c argv[2]; w.navigate(o.str()); w.run(); return 0; } Compile it on GNU/Linux like this and don’t you worry, it takes a fraction of a second:\nc++ clogframe.cpp -ldl `pkg-config --cflags --libs gtk+-3.0 webkit2gtk-4.0` -o clogframe (see its repo for other platforms)\nthis gives you a clogframe binary. Put it in your $PATH or remember its location. It’s just a short C++ binary, so it weights 197Kb.\nNow, back to your web app that you wrote in Common Lisp and that is waiting to be shipped to users.\nStart your web app. Say it is started on port 4284.\nFrom the Lisp side, open a CLOG Frame window like this\n(uiop:launch-program (list \"./clogframe\" \"Admin\" (format nil \"~A/admin/\" 4284) ;; window dimensions (strings) \"1280\" \"840\")) and voilà.\nNow for the cross-platform part, you’ll need to build clogframe and your web app on the target OS (like with any CL app). Webview.h is cross-platform. Leave us a comment when you have a good CI setup for the three main OSes (I am studying 40ants/ci and make-common-lisp-program for now).",
    "description": "Web views are lightweight and cross-platform. They are nowadays a good solution to ship a GUI program to your users.\nWe present two: WebUI and Webview.h, through CLOG Frame.\nInfo This page appeared first on lisp-journey: three web views for Common Lisp, cross-platform GUIs.\nWebUI WebUI is a new kid in town. It is in development, it has bugs. You can view it as a wrapper around a browser window (or webview.h).",
    "tags": [],
    "title": "Web views: cross-platform GUIs",
    "uri": "/building-blocks/web-views/index.html"
  },
  {
    "breadcrumb": "",
    "content": "We’ll see first: Reblocks.\nWeblocks was an old framework developed by Slava Akhmechet, Stephen Compall and Leslie Polzer. After nine calm years, it saw a very active update, refactoring and rewrite effort by Alexander Artemenko. This active project is named Reblocks.\nThe Ultralisp website is an example Reblocks website in production known in the CL community.\nIt isn’t the only solution that aims at making writing interactive web apps easier, where the client logic can be brought to the back-end. See also:\nCLOG ISSR Of course, a special mention goes to HTMX, which is language agnostic and backend agnostic. It works well with Common Lisp.",
    "description": "We’ll see first: Reblocks.\nWeblocks was an old framework developed by Slava Akhmechet, Stephen Compall and Leslie Polzer. After nine calm years, it saw a very active update, refactoring and rewrite effort by Alexander Artemenko. This active project is named Reblocks.\nThe Ultralisp website is an example Reblocks website in production known in the CL community.\nIt isn’t the only solution that aims at making writing interactive web apps easier, where the client logic can be brought to the back-end. See also:",
    "tags": [],
    "title": "Isomorphic web frameworks",
    "uri": "/isomorphic-web-frameworks/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Other tutorials:\nNeil Munro’s Clack/Lack/Ningle tutorial the Cookbook Project skeletons and demos:\ncl-cookieweb - a web project template lisp-web-template-productlist, a simple project template with Hunchentoot, Easy-Routes, Djula and Bulma CSS. lisp-web-live-reload-example - a toy project to show how to interact with a running web app. Libraries:\nawesome-cl",
    "description": "Other tutorials:\nNeil Munro’s Clack/Lack/Ningle tutorial the Cookbook Project skeletons and demos:\ncl-cookieweb - a web project template lisp-web-template-productlist, a simple project template with Hunchentoot, Easy-Routes, Djula and Bulma CSS. lisp-web-live-reload-example - a toy project to show how to interact with a running web app. Libraries:\nawesome-cl",
    "tags": [],
    "title": "See also",
    "uri": "/see-also/index.html"
  },
  {
    "breadcrumb": "",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/categories/index.html"
  },
  {
    "breadcrumb": "",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/tags/index.html"
  }
]
